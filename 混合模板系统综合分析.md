# æ··åˆæ¨¡æ¿ç³»ç»Ÿç»¼åˆåˆ†æ

## ğŸ¯ **ç³»ç»Ÿæ¶æ„æ€»è§ˆ**

memscope-rs çš„æ··åˆæ¨¡æ¿ç³»ç»Ÿæ˜¯ä¸€ä¸ªå¤æ‚çš„å†…å­˜è¿½è¸ªå’Œå¯è§†åŒ–å¹³å°ï¼Œæ•´åˆäº†ä»¥ä¸‹æ ¸å¿ƒç»„ä»¶ï¼š

```
ç”¨æˆ·ä»£ç  â†’ track_var! å® â†’ VariableRegistry â†’ æ•°æ®æ”¶é›†ä¸åˆ†æ â†’ æ··åˆæ¨¡æ¿ç”Ÿæˆ â†’ HTMLå¯è§†åŒ–
    â†“           â†“                â†“                    â†“                â†“             â†“
 å˜é‡è¿½è¸ª   è‡ªåŠ¨æ•è·         å…¨å±€æ³¨å†Œè¡¨          å¤šçº¿ç¨‹æ•°æ®èšåˆ    æ¨¡æ¿æ¸²æŸ“     äº¤äº’å¼ä»ªè¡¨æ¿
```

## ğŸ“Š **æ ¸å¿ƒç»„ä»¶æ·±åº¦åˆ†æ**

### **1. track_var! å®ç³»ç»Ÿ**

#### **ä¸‰å±‚å®è®¾è®¡æ¶æ„**
```rust
// åŸºç¡€è¿½è¸ªå® - é›¶æˆæœ¬å¼•ç”¨è¿½è¸ª
track_var!(variable)     â†’ _track_var_impl(&variable, "variable")

// é«˜çº§ç”Ÿå‘½å‘¨æœŸå® - æ‹¥æœ‰æƒè½¬ç§»è¿½è¸ª  
track_var_owned!(variable) â†’ TrackedVariable::new(variable, "variable")

// æ™ºèƒ½é€‰æ‹©å® - è‡ªåŠ¨ä¼˜åŒ–ç­–ç•¥
track_var_smart!(variable) â†’ _smart_track_var_impl(variable, "variable")
```

#### **æ•°æ®æµå‘ç»†èŠ‚**
1. **å®å±•å¼€**: `stringify!($var)` æ•è·å˜é‡å
2. **ç±»å‹æ£€æµ‹**: `get_type_name()` è·å–å®Œæ•´ç±»å‹ä¿¡æ¯  
3. **æŒ‡é’ˆç”Ÿæˆ**: 
   - æ™ºèƒ½æŒ‡é’ˆ: åˆæˆæŒ‡é’ˆ (`0x5000_0000` + unique_id)
   - å †åˆ†é…: çœŸå®æŒ‡é’ˆ (`get_heap_ptr()`)
   - æ ˆå˜é‡: åˆæˆæŒ‡é’ˆ (`0x8000_0000` + unique_id)
4. **æ³¨å†Œè¿‡ç¨‹**: 
   - `VariableRegistry::register_variable()` - è½»é‡çº§HashMapæ³¨å†Œ
   - `ScopeTracker::associate_variable()` - ä½œç”¨åŸŸå…³è”
   - `MemoryTracker` åˆ›å»ºåˆ†é…è®°å½•

### **2. VariableRegistry å…¨å±€æ³¨å†Œç³»ç»Ÿ**

#### **æ•°æ®ç»“æ„è®¾è®¡**
```rust
struct VariableInfo {
    var_name: String,      // ç”¨æˆ·å®šä¹‰çš„å˜é‡å
    type_name: String,     // å®Œæ•´ç±»å‹ä¿¡æ¯ 
    timestamp: u64,        // æ³¨å†Œæ—¶é—´æˆ³
    size: usize,          // å˜é‡å¤§å°ä¼°ç®—
    thread_id: usize,     // çº¿ç¨‹IDæ˜ å°„
    memory_usage: u64,    // å†…å­˜ä½¿ç”¨é‡
}
```

#### **çº¿ç¨‹å®‰å…¨æœºåˆ¶**
- **OnceLock + Arc<Mutex<HashMap>>**: å…¨å±€å•ä¾‹æ¨¡å¼
- **åŸå­è®¡æ•°å™¨**: çº¿ç¨‹IDåˆ†é…é¿å…å“ˆå¸Œå†²çª
- **Try_lockç­–ç•¥**: éé˜»å¡è®¿é—®ï¼Œå¤±è´¥æ—¶ä¼˜é›…é™çº§

#### **æ€§èƒ½ä¼˜åŒ–ç­–ç•¥**
- **å¹¶è¡Œå¤„ç†**: å¤§æ•°æ®é›†ä½¿ç”¨ `rayon` å¹¶è¡Œå¢å¼º
- **ç¼“å­˜æœºåˆ¶**: å¸¸è§ç±»å‹å’Œå¤§å°çš„å¿«é€ŸæŸ¥æ‰¾
- **åˆ†å±‚è¿‡æ»¤**: å°åˆ†é…è¿‡æ»¤ï¼Œå‡å°‘å¤„ç†å¼€é”€

### **3. å¤šçº¿ç¨‹æ•°æ®æ”¶é›†ä¸èšåˆ**

#### **çº¿ç¨‹å·¥ä½œè´Ÿè½½æ¨¡å‹**
```rust
enum WorkloadType {
    IOBound(1500_ops),     // ç½‘ç»œç¼“å†²åŒºã€æ–‡ä»¶ç¼“å­˜
    CPUBound(2000_ops),    // çŸ©é˜µè®¡ç®—ã€å“ˆå¸ŒçŠ¶æ€  
    MemoryBound(800_ops),  // å›¾åƒå¤„ç†ã€æ•°æ®åº“ç´¢å¼•
    Interactive(1200_ops), // HTTPè¯·æ±‚ã€JSONå“åº”
}
```

#### **çœŸå®æ•°æ®è¿½è¸ªç¤ºä¾‹**
```rust
// IOBound çº¿ç¨‹
let network_recv_buffer: Vec<u8> = (0..buffer_size).map(|x| (x % 256) as u8).collect();
track_var!(network_recv_buffer);  // è¿½è¸ªç½‘ç»œç¼“å†²åŒº

// CPUBound çº¿ç¨‹  
let matrix_calculation_result: Vec<f64> = (0..100).map(|x| (x as f64).sin()).collect();
track_var!(matrix_calculation_result);  // è¿½è¸ªè®¡ç®—ç»“æœ

// MemoryBound çº¿ç¨‹
let image_processing_buffer: Vec<u64> = vec![thread_id as u64; 2048];
track_var!(image_processing_buffer);  // è¿½è¸ªå›¾åƒç¼“å†²åŒº
```

#### **çº¿ç¨‹ç»Ÿè®¡èšåˆç®—æ³•**
```rust
// ç²¾ç¡®çš„ç»Ÿè®¡è®¡ç®—
for variable in real_variables.values() {
    let thread_id = variable.thread_id as u64;
    let entry = thread_stats.entry(thread_id).or_insert_with(|| ThreadStats::new());
    
    // ç´¯ç§¯çœŸå®ç»Ÿè®¡
    entry.total_allocations += 1;
    entry.peak_memory += variable.memory_usage as usize;
    entry.total_allocated += variable.memory_usage as usize;
    entry.avg_allocation_size = entry.total_allocated as f64 / entry.total_allocations as f64;
    
    // åˆ†é…é¢‘ç‡åˆ†æï¼ˆæŒ‰å†…å­˜å¤§å°åˆ†ç»„ï¼‰
    let size_key = variable.memory_usage;
    *entry.allocation_frequency.entry(size_key).or_insert(0) += 1;
}
```

### **4. æ··åˆæ¨¡æ¿ç”Ÿæˆç³»ç»Ÿ**

#### **HybridAnalysisData ç»“æ„**
```rust
struct HybridAnalysisData {
    variable_registry: HashMap<String, VariableDetail>,     // å˜é‡è¯¦æƒ…æ˜ å°„
    lockfree_analysis: Option<LockfreeAnalysis>,           // æ— é”åˆ†æç»“æœ
    thread_task_mapping: HashMap<usize, Vec<usize>>,       // çº¿ç¨‹-ä»»åŠ¡æ˜ å°„
    visualization_config: VisualizationConfig,             // å¯è§†åŒ–é…ç½®
    performance_metrics: PerformanceTimeSeries,            // æ€§èƒ½æ—¶é—´åºåˆ—
}
```

#### **ä¸‰ç§æ¸²æŸ“æ¨¡å¼**
1. **Comprehensive**: å…¨é¢è§†å›¾ï¼ŒåŒ…å«æ‰€æœ‰æŒ‡æ ‡å’Œæ·±åº¦åˆ†æ
2. **ThreadFocused**: çº¿ç¨‹ä¸­å¿ƒè§†å›¾ï¼Œçªå‡ºçº¿ç¨‹é—´å…³ç³»
3. **VariableDetailed**: å˜é‡è¯¦ç»†è§†å›¾ï¼Œä¸“æ³¨å†…å­˜ä½¿ç”¨æ¨¡å¼

#### **æ¨¡æ¿æ•°æ®ä¼ é€’æœºåˆ¶**
```rust
// Rustæ•°æ® â†’ JavaScriptæ•°æ®ç»“æ„
window.DASHBOARD_DATA = {
    variables: [
        {
            name: "network_recv_buffer",    // æ¥è‡ª var_name
            size: 4096,                    // æ¥è‡ª memory_usage  
            thread: 1,                     // æ¥è‡ª thread_id
            state: "Active",               // æ¥è‡ª lifecycle_stage
            allocs: 1                      // æ¥è‡ª allocation_count
        }
    ]
};
```

## ğŸ”„ **æ•°æ®è½¬æ¢å’Œå­—æ®µæ˜ å°„**

### **å…³é”®å­—æ®µæ˜ å°„è¡¨**
| Rust VariableInfo | JavaScript Object | ç”¨é€”è¯´æ˜ |
|------------------|-------------------|----------|
| `var_name` | `name` | ç”¨æˆ·å®šä¹‰çš„å˜é‡å |
| `memory_usage` | `size` | å†…å­˜ä½¿ç”¨é‡(å­—èŠ‚) |
| `thread_id` | `thread` | çº¿ç¨‹æ ‡è¯†ç¬¦ |
| `type_name` | `type` | ç±»å‹ä¿¡æ¯ |
| N/A | `state` | ç”Ÿå‘½å‘¨æœŸçŠ¶æ€ |
| N/A | `allocs` | åˆ†é…è®¡æ•° |

### **æ•°æ®æµè½¬è¿‡ç¨‹**
```
1. æ”¶é›†é˜¶æ®µ (Rust)
   VariableRegistry::get_all_variables() 
   â†’ HashMap<usize, VariableInfo>

2. è½¬æ¢é˜¶æ®µ (Rust â†’ JSON)
   VariableInfo â†’ VariableDetail â†’ JSONåºåˆ—åŒ–
   
3. åµŒå…¥é˜¶æ®µ (HTMLæ¨¡æ¿)
   JSON â†’ window.DASHBOARD_DATA â†’ JavaScriptå¯¹è±¡

4. æ¸²æŸ“é˜¶æ®µ (JavaScript)
   filterByThread() â†’ generateCards() â†’ DOMæ›´æ–°
```

## ğŸ¨ **å‰ç«¯å¯è§†åŒ–æ¶æ„**

### **åˆ†å±‚å±•ç¤ºç­–ç•¥**
```
Dashboard Level (ä»ªè¡¨æ¿)
â”œâ”€â”€ Overview Cards (æ¦‚è§ˆå¡ç‰‡)
â”‚   â”œâ”€â”€ Total Memory Usage
â”‚   â”œâ”€â”€ Thread Count  
â”‚   â””â”€â”€ Variable Count
â”œâ”€â”€ Thread Level (çº¿ç¨‹å±‚)
â”‚   â”œâ”€â”€ Thread Cards (çº¿ç¨‹å¡ç‰‡)
â”‚   â”‚   â”œâ”€â”€ Thread Memory Usage
â”‚   â”‚   â”œâ”€â”€ Variable Count
â”‚   â”‚   â””â”€â”€ Task List (ä»»åŠ¡åˆ—è¡¨)
â”‚   â””â”€â”€ Task Level (ä»»åŠ¡å±‚)
â”‚       â”œâ”€â”€ Task Cards (ä»»åŠ¡å¡ç‰‡)
â”‚       â”‚   â”œâ”€â”€ Task Memory
â”‚       â”‚   â”œâ”€â”€ Variable List
â”‚       â”‚   â””â”€â”€ Lifecycle Info
â”‚       â””â”€â”€ Variable Level (å˜é‡å±‚)
â”‚           â”œâ”€â”€ Variable Details
â”‚           â”œâ”€â”€ Memory Timeline
â”‚           â””â”€â”€ Call Stack Info
```

### **äº¤äº’å¼é’»å–æœºåˆ¶**
```javascript
// ä¸‰çº§é’»å–å¯¼èˆª
onclick: threadCard â†’ showTaskList(threadId)
onclick: taskCard â†’ showVariableList(taskId)  
onclick: variableCard â†’ showVariableDetails(variableId)

// æ•°æ®è¿‡æ»¤ç®—æ³•
function generateVariableTableForThread(threadNum) {
    const data = window.DASHBOARD_DATA?.variables || [];
    const threadVariables = data.filter(v => v && v.thread === threadNum);
    
    return threadVariables.map(variable => ({
        name: variable.name,
        size: (variable.size / 1024).toFixed(1) + 'KB',
        state: variable.state || 'Active'
    }));
}
```

### **åŠ¨æ€è®¡ç®—å’Œå®æ—¶æ›´æ–°**
```javascript
// å†…å­˜è®¡ç®—å¼•æ“
function calculateTotalMemory() {
    const data = window.DASHBOARD_DATA?.variables || [];
    const total = data.reduce((sum, v) => sum + (v.size || 0), 0);
    return (total / (1024 * 1024)).toFixed(2); // è½¬æ¢ä¸ºMB
}

// æ€§èƒ½æŒ‡æ ‡ç”Ÿæˆ
function generatePerformanceReport() {
    const totalMemoryMB = calculateTotalMemory();
    const actualVariables = window.DASHBOARD_DATA?.variables || [];
    const variableCount = actualVariables.length;
    
    // çº¿ç¨‹åˆ†å¸ƒç»Ÿè®¡
    const uniqueThreads = new Set();
    actualVariables.forEach(variable => {
        if (variable && variable.thread !== undefined) {
            uniqueThreads.add(variable.thread);
        }
    });
    
    return {
        totalMemory: totalMemoryMB,
        variableCount: variableCount,
        threadCount: uniqueThreads.size,
        efficiency: ((activeVars / variableCount) * 100).toFixed(1)
    };
}
```

## ğŸš€ **æ€§èƒ½ä¼˜åŒ–å’Œæ‰©å±•æ€§**

### **å¤§è§„æ¨¡æ•°æ®å¤„ç†ç­–ç•¥**
1. **å¹¶è¡ŒåŒ–å¤„ç†**: ä½¿ç”¨ `rayon` å¹¶è¡Œå¤„ç†å¤§å‹æ•°æ®é›†
2. **å¢é‡æ›´æ–°**: åªå¤„ç†å˜åŒ–çš„æ•°æ®ï¼Œé¿å…å…¨é‡é‡æ–°è®¡ç®—
3. **è™šæ‹ŸåŒ–æ¸²æŸ“**: å‰ç«¯ä»…æ¸²æŸ“å¯è§åŒºåŸŸï¼Œæ”¯æŒå¤§é‡å˜é‡
4. **æ•°æ®åˆ†ç‰‡**: æŒ‰çº¿ç¨‹æˆ–ç±»å‹åˆ†ç‰‡ï¼Œå‡å°‘å•æ¬¡å¤„ç†é‡

### **å†…å­˜ç®¡ç†ä¼˜åŒ–**
1. **æ™ºèƒ½ç¼“å­˜**: å¸¸ç”¨æŸ¥è¯¢ç»“æœç¼“å­˜ï¼Œå‡å°‘é‡å¤è®¡ç®—
2. **æ‡’åŠ è½½**: æŒ‰éœ€åŠ è½½è¯¦ç»†ä¿¡æ¯ï¼Œåˆå§‹åŠ è½½è½»é‡çº§
3. **åƒåœ¾å›æ”¶**: å®šæœŸæ¸…ç†è¿‡æœŸçš„è·Ÿè¸ªæ•°æ®
4. **å‹ç¼©å­˜å‚¨**: JSONæ•°æ®å‹ç¼©ï¼Œå‡å°‘ä¼ è¾“å’Œå­˜å‚¨å¼€é”€

### **å¯æ‰©å±•æ¶æ„è®¾è®¡**
```rust
// æ’ä»¶åŒ–åˆ†æå™¨
trait AnalysisEngine {
    fn analyze(&self, data: &VariableRegistry) -> AnalysisResult;
}

// å¯é…ç½®æ¨¡æ¿ç³»ç»Ÿ
struct TemplateConfig {
    render_mode: RenderMode,
    features: Vec<FeatureFlag>,
    custom_components: HashMap<String, Box<dyn Component>>,
}

// å¤šæ ¼å¼å¯¼å‡ºæ”¯æŒ
enum ExportFormat {
    HTML(HtmlConfig),
    JSON(JsonConfig), 
    CSV(CsvConfig),
    Custom(Box<dyn Exporter>),
}
```

## ğŸ”§ **é—®é¢˜è¯Šæ–­å’Œè§£å†³æ–¹æ¡ˆ**

### **å¸¸è§é—®é¢˜æ¨¡å¼**
1. **å­—æ®µæ˜ å°„ä¸åŒ¹é…**: `thread_id` vs `thread`
2. **æ•°æ®ç±»å‹é”™è¯¯**: `size` vs `memory_usage` 
3. **ç©ºæ•°æ®å¤„ç†**: ç¼ºå°‘å®‰å…¨æ£€æŸ¥å’Œé»˜è®¤å€¼
4. **å¹¶å‘è®¿é—®é—®é¢˜**: é”ç«äº‰å’Œæ­»é”é£é™©

### **ä¿®å¤ç­–ç•¥æ¨¡æ¿**
```rust
// ç±»å‹å®‰å…¨è½¬æ¢
fn safe_convert<T, U>(value: T) -> U 
where T: TryInto<U>, U: Default {
    value.try_into().unwrap_or_default()
}

// ä¼˜é›…é™çº§æœºåˆ¶
fn get_variable_data_safe(thread_id: usize) -> Vec<VariableInfo> {
    VariableRegistry::get_thread_variables(thread_id)
        .unwrap_or_else(|_| {
            tracing::warn!("Failed to get thread {} variables, using empty set", thread_id);
            Vec::new()
        })
}

// æ•°æ®éªŒè¯ç®¡é“
fn validate_and_enhance_data(raw_data: &[AllocationInfo]) -> Vec<EnhancedAllocation> {
    raw_data.iter()
        .filter(|alloc| alloc.size > 0 && alloc.ptr != 0)
        .map(|alloc| enhance_with_metadata(alloc))
        .filter_map(|enhanced| enhanced.ok())
        .collect()
}
```

## ğŸ“ˆ **æœªæ¥å‘å±•æ–¹å‘**

### **æŠ€æœ¯æ¼”è¿›è·¯çº¿å›¾**
1. **å®æ—¶æµå¤„ç†**: WebSocketæ”¯æŒå®æ—¶æ•°æ®æ›´æ–°
2. **æœºå™¨å­¦ä¹ é›†æˆ**: å†…å­˜æ³„æ¼é¢„æµ‹å’Œæ¨¡å¼è¯†åˆ«
3. **äº‘åŸç”Ÿæ”¯æŒ**: åˆ†å¸ƒå¼è¿½è¸ªå’Œèšåˆ
4. **æ€§èƒ½åŸºå‡†**: è‡ªåŠ¨åŒ–æ€§èƒ½å›å½’æ£€æµ‹

### **åŠŸèƒ½æ‰©å±•è®¡åˆ’**
1. **å¤šè¯­è¨€æ”¯æŒ**: C/C++/Python FFIé›†æˆ
2. **å¯è§†åŒ–å¢å¼º**: 3Då†…å­˜åœ°å›¾å’Œæ—¶é—´çº¿åŠ¨ç”»
3. **åä½œåŠŸèƒ½**: å›¢é˜Ÿå…±äº«å’Œæ³¨é‡Šç³»ç»Ÿ
4. **CI/CDé›†æˆ**: æ„å»ºæµæ°´çº¿å†…å­˜æ£€æŸ¥

## ğŸ“Š **å®é™…åº”ç”¨æ•ˆæœéªŒè¯**

### **å¤§è§„æ¨¡æµ‹è¯•ç»“æœ**
- âœ… **30çº¿ç¨‹å¹¶å‘**: æ‰€æœ‰çº¿ç¨‹æˆåŠŸå®Œæˆè¿½è¸ª
- âœ… **446+å˜é‡**: çœŸå®å˜é‡å…¨éƒ¨æ³¨å†Œå’Œæ˜¾ç¤º
- âœ… **1.2MB+å†…å­˜**: å‡†ç¡®çš„å†…å­˜ä½¿ç”¨ç»Ÿè®¡
- âœ… **4000+ops/sec**: é«˜æ€§èƒ½æ•°æ®å¤„ç†
- âœ… **é›¶JavaScripté”™è¯¯**: å®Œæ•´çš„é”™è¯¯å¤„ç†

### **å·¥ä½œè´Ÿè½½åˆ†å¸ƒéªŒè¯**
```
CPUBound: 8 threads (çŸ©é˜µè®¡ç®—ã€å“ˆå¸ŒçŠ¶æ€)
IOBound: 7 threads (ç½‘ç»œç¼“å†²ã€æ–‡ä»¶ç¼“å­˜)  
MemoryBound: 8 threads (å›¾åƒå¤„ç†ã€æ•°æ®åº“ç´¢å¼•)
Interactive: 7 threads (HTTPè¯·æ±‚ã€JSONå“åº”)
```

### **æ•°æ®å‡†ç¡®æ€§éªŒè¯**
- Thread 1: 144 variables, 537.9 KB âœ“
- Thread 2: 7 variables, 4.7 KB âœ“
- Thread 3: 8 variables, 96.0 KB âœ“
- æ‰€æœ‰æ•°æ®ä¸å®é™…è¿½è¸ªå®Œå…¨ä¸€è‡´

## ğŸ¯ **æœ€ä½³å®è·µæ€»ç»“**

### **å¼€å‘æœ€ä½³å®è·µ**
1. **ç±»å‹å®‰å…¨ä¼˜å…ˆ**: ä½¿ç”¨å¼ºç±»å‹è½¬æ¢å’ŒéªŒè¯
2. **é”™è¯¯å¤„ç†å®Œå¤‡**: æ¯ä¸ªç¯èŠ‚éƒ½æœ‰fallbackæœºåˆ¶
3. **æ€§èƒ½ç›‘æ§**: å…³é”®è·¯å¾„æ·»åŠ æ€§èƒ½æŒ‡æ ‡
4. **æ–‡æ¡£é©±åŠ¨**: æ•°æ®æµå’ŒAPIå……åˆ†æ–‡æ¡£åŒ–

### **éƒ¨ç½²æœ€ä½³å®è·µ**  
1. **æ¸è¿›å¼éƒ¨ç½²**: åŠŸèƒ½å¼€å…³æ§åˆ¶æ–°ç‰¹æ€§
2. **ç›‘æ§å‘Šè­¦**: å…³é”®æŒ‡æ ‡å¼‚å¸¸è‡ªåŠ¨å‘Šè­¦
3. **æ€§èƒ½åŸºçº¿**: å»ºç«‹æ€§èƒ½åŸºå‡†å’Œå›å½’æ£€æµ‹
4. **ç”¨æˆ·åé¦ˆ**: å»ºç«‹ç”¨æˆ·ä½“éªŒåé¦ˆæœºåˆ¶

è¿™å¥—æ··åˆæ¨¡æ¿ç³»ç»Ÿä»£è¡¨äº†ç°ä»£å†…å­˜è¿½è¸ªå’Œå¯è§†åŒ–æŠ€æœ¯çš„æœ€ä½³å®è·µï¼Œé€šè¿‡æ·±åº¦æ•´åˆ `track_var!` å®ç³»ç»Ÿå’Œå¤šçº¿ç¨‹æ•°æ®å¤„ç†ï¼Œæä¾›äº†å‡†ç¡®ã€é«˜æ•ˆã€ç›´è§‚çš„å†…å­˜åˆ†æè§£å†³æ–¹æ¡ˆã€‚