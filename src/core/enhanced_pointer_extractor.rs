//! Enhanced pointer extraction with real pointer prioritization
//!
//! This module provides improved pointer extraction logic that prioritizes
//! real heap pointers over synthetic ones, with clear marking of pointer types.

use crate::Trackable;
use serde::{Deserialize, Serialize};

/// Information about a pointer and its origin
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum PointerInfo {
    /// Real heap pointer obtained from the actual allocation
    Real(usize),
    /// Synthetic pointer generated when real pointer is unavailable
    Synthetic {
        ptr: usize,
        reason: SyntheticReason,
    },
}

/// Reasons why a synthetic pointer was generated
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
pub enum SyntheticReason {
    /// No heap allocation (stack-only data)
    NoHeapAllocation,
    /// Empty container (no capacity allocated)
    EmptyContainer,
    /// Smart pointer without direct heap access
    SmartPointerIndirection,
    /// Complex type requiring synthetic tracking
    ComplexType,
    /// Invalid or unsafe pointer detected
    InvalidPointer,
}

/// Enhanced pointer extractor with validation and categorization
pub struct EnhancedPointerExtractor;

impl EnhancedPointerExtractor {
    /// Extract pointer information with validation and categorization
    pub fn extract_pointer_info<T: Trackable>(value: &T) -> PointerInfo {
        match value.get_heap_ptr() {
            Some(ptr) if Self::is_valid_heap_pointer(ptr) => {
                PointerInfo::Real(ptr)
            }
            Some(ptr) if Self::is_synthetic_pointer(ptr) => {
                // This is already a synthetic pointer from the Trackable implementation
                let reason = Self::determine_synthetic_reason(ptr);
                PointerInfo::Synthetic { ptr, reason }
            }
            Some(_ptr) => {
                // Invalid pointer, generate a new synthetic one
                let synthetic = Self::generate_synthetic_pointer();
                PointerInfo::Synthetic {
                    ptr: synthetic,
                    reason: SyntheticReason::InvalidPointer,
                }
            }
            None => {
                // No pointer available, generate synthetic
                let synthetic = Self::generate_synthetic_pointer();
                PointerInfo::Synthetic {
                    ptr: synthetic,
                    reason: SyntheticReason::NoHeapAllocation,
                }
            }
        }
    }

    /// Check if a pointer is a valid heap pointer
    pub fn is_valid_heap_pointer(ptr: usize) -> bool {
        // Check if pointer is in reasonable heap address range
        // Exclude null pointer and very low addresses (likely stack or invalid)
        if ptr < 0x1000 {
            return false;
        }

        // Exclude very high addresses that are likely invalid
        #[cfg(target_pointer_width = "64")]
        {
            if ptr > 0x7FFF_FFFF_FFFF_FFFF {
                return false;
            }
        }

        #[cfg(target_pointer_width = "32")]
        {
            if ptr > 0x7FFF_FFFF {
                return false;
            }
        }

        // Check if it's not a synthetic pointer
        !Self::is_synthetic_pointer(ptr)
    }

    /// Check if a pointer is synthetic (generated by our tracking system)
    pub fn is_synthetic_pointer(ptr: usize) -> bool {
        // Check for known synthetic pointer ranges
        match ptr {
            // Range used by Rc/Arc synthetic pointers
            0x5000_0000..=0x5FFF_FFFF => true,
            // Range used by fast tracking synthetic pointers
            0x8000_0000..=0x8FFF_FFFF => true,
            // Ranges used by advanced trackable macro
            0xA000_0000..=0xFFFF_FFFF => true,
            _ => false,
        }
    }

    /// Determine the reason for synthetic pointer generation based on pointer value
    fn determine_synthetic_reason(ptr: usize) -> SyntheticReason {
        match ptr {
            0x5000_0000..=0x5FFF_FFFF => SyntheticReason::SmartPointerIndirection,
            0x8000_0000..=0x8FFF_FFFF => SyntheticReason::NoHeapAllocation,
            0xA000_0000..=0xFFFF_FFFF => SyntheticReason::ComplexType,
            _ => SyntheticReason::InvalidPointer,
        }
    }

    /// Generate a new synthetic pointer
    fn generate_synthetic_pointer() -> usize {
        use std::sync::atomic::{AtomicUsize, Ordering};
        static SYNTHETIC_COUNTER: AtomicUsize = AtomicUsize::new(0);
        
        let id = SYNTHETIC_COUNTER.fetch_add(1, Ordering::Relaxed);
        0x9000_0000 + (id % 0x0FFF_FFFF)
    }

    /// Enhanced extraction for Vec with capacity validation
    pub fn extract_vec_pointer<T>(vec: &Vec<T>) -> PointerInfo {
        if vec.capacity() > 0 {
            let ptr = vec.as_ptr() as usize;
            if Self::is_valid_heap_pointer(ptr) {
                PointerInfo::Real(ptr)
            } else {
                PointerInfo::Synthetic {
                    ptr: Self::generate_synthetic_pointer(),
                    reason: SyntheticReason::InvalidPointer,
                }
            }
        } else {
            PointerInfo::Synthetic {
                ptr: Self::generate_synthetic_pointer(),
                reason: SyntheticReason::EmptyContainer,
            }
        }
    }

    /// Enhanced extraction for String with capacity validation
    pub fn extract_string_pointer(string: &String) -> PointerInfo {
        if string.capacity() > 0 {
            let ptr = string.as_ptr() as usize;
            if Self::is_valid_heap_pointer(ptr) {
                PointerInfo::Real(ptr)
            } else {
                PointerInfo::Synthetic {
                    ptr: Self::generate_synthetic_pointer(),
                    reason: SyntheticReason::InvalidPointer,
                }
            }
        } else {
            PointerInfo::Synthetic {
                ptr: Self::generate_synthetic_pointer(),
                reason: SyntheticReason::EmptyContainer,
            }
        }
    }

    /// Enhanced extraction for Box with validation
    pub fn extract_box_pointer<T>(boxed: &Box<T>) -> PointerInfo {
        let ptr = boxed.as_ref() as *const T as usize;
        if Self::is_valid_heap_pointer(ptr) {
            PointerInfo::Real(ptr)
        } else {
            PointerInfo::Synthetic {
                ptr: Self::generate_synthetic_pointer(),
                reason: SyntheticReason::InvalidPointer,
            }
        }
    }

    /// Enhanced extraction for HashMap with bucket validation
    pub fn extract_hashmap_pointer<K, V, S>(map: &std::collections::HashMap<K, V, S>) -> PointerInfo {
        if map.is_empty() {
            PointerInfo::Synthetic {
                ptr: Self::generate_synthetic_pointer(),
                reason: SyntheticReason::EmptyContainer,
            }
        } else {
            // HashMap internal structure is complex, use synthetic pointer
            PointerInfo::Synthetic {
                ptr: Self::generate_synthetic_pointer(),
                reason: SyntheticReason::ComplexType,
            }
        }
    }

    /// Get pointer statistics for analysis
    pub fn get_pointer_statistics(pointers: &[PointerInfo]) -> PointerStatistics {
        let mut real_count = 0;
        let mut synthetic_count = 0;
        let mut reason_counts = std::collections::HashMap::new();

        for pointer in pointers {
            match pointer {
                PointerInfo::Real(_) => real_count += 1,
                PointerInfo::Synthetic { reason, .. } => {
                    synthetic_count += 1;
                    *reason_counts.entry(reason.clone()).or_insert(0) += 1;
                }
            }
        }

        let total = pointers.len();
        let real_ratio = if total > 0 { real_count as f64 / total as f64 } else { 0.0 };

        PointerStatistics {
            total_pointers: total,
            real_pointers: real_count,
            synthetic_pointers: synthetic_count,
            real_pointer_ratio: real_ratio,
            synthetic_reasons: reason_counts,
        }
    }
}

/// Statistics about pointer extraction
#[derive(Debug, Clone, Serialize)]
pub struct PointerStatistics {
    pub total_pointers: usize,
    pub real_pointers: usize,
    pub synthetic_pointers: usize,
    pub real_pointer_ratio: f64,
    pub synthetic_reasons: std::collections::HashMap<SyntheticReason, usize>,
}

/// Enhanced Trackable trait with pointer info
pub trait EnhancedTrackable {
    /// Get enhanced pointer information
    fn get_pointer_info(&self) -> PointerInfo;
    
    /// Get size estimate for the tracked data
    fn get_size_estimate(&self) -> usize;
    
    /// Get type information
    fn get_type_info(&self) -> TypeInfo;
}

/// Type information for enhanced tracking
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TypeInfo {
    pub type_name: String,
    pub category: TypeCategory,
    pub complexity_score: u32,
    pub is_heap_allocated: bool,
}

/// Categories of types for better analysis
#[derive(Debug, Clone, Serialize, Deserialize)]
#[derive(PartialEq)]
pub enum TypeCategory {
    Primitive,
    Collection,
    SmartPointer,
    Complex,
    Atomic,
    Synchronization,
    Custom,
}

// Implement EnhancedTrackable for common types
impl<T> EnhancedTrackable for Vec<T> {
    fn get_pointer_info(&self) -> PointerInfo {
        EnhancedPointerExtractor::extract_vec_pointer(self)
    }

    fn get_size_estimate(&self) -> usize {
        std::mem::size_of::<Vec<T>>() + (self.capacity() * std::mem::size_of::<T>())
    }

    fn get_type_info(&self) -> TypeInfo {
        TypeInfo {
            type_name: format!("Vec<{}>", std::any::type_name::<T>()),
            category: TypeCategory::Collection,
            complexity_score: 2,
            is_heap_allocated: self.capacity() > 0,
        }
    }
}

impl EnhancedTrackable for String {
    fn get_pointer_info(&self) -> PointerInfo {
        EnhancedPointerExtractor::extract_string_pointer(self)
    }

    fn get_size_estimate(&self) -> usize {
        std::mem::size_of::<String>() + self.capacity()
    }

    fn get_type_info(&self) -> TypeInfo {
        TypeInfo {
            type_name: "String".to_string(),
            category: TypeCategory::Collection,
            complexity_score: 1,
            is_heap_allocated: self.capacity() > 0,
        }
    }
}

impl<T> EnhancedTrackable for Box<T> {
    fn get_pointer_info(&self) -> PointerInfo {
        EnhancedPointerExtractor::extract_box_pointer(self)
    }

    fn get_size_estimate(&self) -> usize {
        std::mem::size_of::<Box<T>>() + std::mem::size_of::<T>()
    }

    fn get_type_info(&self) -> TypeInfo {
        TypeInfo {
            type_name: format!("Box<{}>", std::any::type_name::<T>()),
            category: TypeCategory::SmartPointer,
            complexity_score: 2,
            is_heap_allocated: true,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_valid_heap_pointer_detection() {
        // Valid heap pointers
        assert!(EnhancedPointerExtractor::is_valid_heap_pointer(0x1000));
        assert!(EnhancedPointerExtractor::is_valid_heap_pointer(0x7FFF_0000));
        
        // Invalid pointers
        assert!(!EnhancedPointerExtractor::is_valid_heap_pointer(0));
        assert!(!EnhancedPointerExtractor::is_valid_heap_pointer(0x100));
        
        // Synthetic pointers
        assert!(!EnhancedPointerExtractor::is_valid_heap_pointer(0x8000_0000));
        assert!(!EnhancedPointerExtractor::is_valid_heap_pointer(0xA000_0000));
    }

    #[test]
    fn test_synthetic_pointer_detection() {
        assert!(EnhancedPointerExtractor::is_synthetic_pointer(0x5000_0000));
        assert!(EnhancedPointerExtractor::is_synthetic_pointer(0x8000_0000));
        assert!(EnhancedPointerExtractor::is_synthetic_pointer(0xA000_0000));
        
        assert!(!EnhancedPointerExtractor::is_synthetic_pointer(0x1000));
        assert!(!EnhancedPointerExtractor::is_synthetic_pointer(0x7FFF_0000));
    }

    #[test]
    fn test_vec_pointer_extraction() {
        let vec = vec![1, 2, 3, 4, 5];
        let pointer_info = EnhancedPointerExtractor::extract_vec_pointer(&vec);
        
        match pointer_info {
            PointerInfo::Real(_) => {
                // This is expected for a Vec with capacity
            }
            PointerInfo::Synthetic { reason, .. } => {
                panic!("Expected real pointer, got synthetic: {:?}", reason);
            }
        }
    }

    #[test]
    fn test_empty_vec_pointer_extraction() {
        let vec: Vec<i32> = Vec::new();
        let pointer_info = EnhancedPointerExtractor::extract_vec_pointer(&vec);
        
        match pointer_info {
            PointerInfo::Synthetic { reason: SyntheticReason::EmptyContainer, .. } => {
                // This is expected for an empty Vec
            }
            _ => {
                panic!("Expected synthetic pointer with EmptyContainer reason");
            }
        }
    }

    #[test]
    fn test_enhanced_trackable_vec() {
        let vec = vec![1, 2, 3];
        let pointer_info = vec.get_pointer_info();
        let size_estimate = Trackable::get_size_estimate(&vec);
        let type_info = vec.get_type_info();
        
        match pointer_info {
            PointerInfo::Real(_) => {
                // Expected for Vec with data
            }
            _ => panic!("Expected real pointer for Vec with data"),
        }
        
        assert!(size_estimate > 0);
        assert_eq!(type_info.category, TypeCategory::Collection);
        assert!(type_info.is_heap_allocated);
    }

    #[test]
    fn test_pointer_statistics() {
        let pointers = vec![
            PointerInfo::Real(0x1000),
            PointerInfo::Real(0x2000),
            PointerInfo::Synthetic {
                ptr: 0x8000_0000,
                reason: SyntheticReason::EmptyContainer,
            },
            PointerInfo::Synthetic {
                ptr: 0x9000_0000,
                reason: SyntheticReason::ComplexType,
            },
        ];
        
        let stats = EnhancedPointerExtractor::get_pointer_statistics(&pointers);
        
        assert_eq!(stats.total_pointers, 4);
        assert_eq!(stats.real_pointers, 2);
        assert_eq!(stats.synthetic_pointers, 2);
        assert_eq!(stats.real_pointer_ratio, 0.5);
        assert_eq!(stats.synthetic_reasons.len(), 2);
    }
}