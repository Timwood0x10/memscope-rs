//! Offline analysis tool for aggregating lock-free multi-threaded binary data.
//!
//! This module processes the binary files generated by thread-local trackers
//! and provides comprehensive analysis across all threads.

use crate::lockfree::tracker::{Event, FrequencyData};
use crate::lockfree::analysis::{AllocationEvent, EventType, InteractionType};
use postcard;
// Removed unused serde imports
use std::collections::HashMap;
use std::path::Path;

use crate::lockfree::analysis::{
    LockfreeAnalysis, ThreadStats, ThreadInteraction, MemoryPeak, 
    PerformanceBottleneck, BottleneckType
};

/// Lock-free multi-threaded data aggregator
pub struct LockfreeAggregator {
    output_dir: std::path::PathBuf,
}

impl LockfreeAggregator {
    pub fn new(output_dir: std::path::PathBuf) -> Self {
        Self { output_dir }
    }

    /// Discover and parse all thread binary files
    pub fn aggregate_all_threads(&self) -> Result<LockfreeAnalysis, Box<dyn std::error::Error>> {
        let mut thread_stats = HashMap::new();
        
        // Discover all thread files
        let thread_files = self.discover_thread_files()?;
        
        for (thread_id, event_file, freq_file) in thread_files {
            let events = self.parse_event_file(&event_file)?;
            let frequencies = self.parse_frequency_file(&freq_file)?;
            
            let stats = self.analyze_thread_data(thread_id, events, frequencies)?;
            thread_stats.insert(thread_id, stats);
        }

        // Perform cross-thread analysis
        let hottest_call_stacks = self.find_hottest_call_stacks(&thread_stats);
        let thread_interactions = self.analyze_thread_interactions(&thread_stats);
        let memory_peaks = self.find_memory_peaks(&thread_stats);
        let performance_bottlenecks = self.detect_performance_bottlenecks(&thread_stats);

        let mut analysis = LockfreeAnalysis::new();
        analysis.thread_stats = thread_stats;
        analysis.hottest_call_stacks = hottest_call_stacks.into_iter()
            .map(|(hash, freq, size)| crate::lockfree::analysis::HotCallStack {
                call_stack_hash: hash,
                total_frequency: freq,
                total_size: size,
                impact_score: freq * size as u64,
                threads: Vec::new(), // Could be populated from thread_stats
            })
            .collect();
        analysis.thread_interactions = thread_interactions;
        analysis.memory_peaks = memory_peaks;
        analysis.performance_bottlenecks = performance_bottlenecks;

        // IMPORTANT: Calculate summary statistics from thread data
        analysis.calculate_summary(std::time::Instant::now());

        Ok(analysis)
    }

    /// Discover all thread binary files in output directory
    fn discover_thread_files(&self) -> Result<Vec<(u64, std::path::PathBuf, std::path::PathBuf)>, Box<dyn std::error::Error>> {
        let mut files = Vec::new();
        
        if !self.output_dir.exists() {
            return Ok(files);
        }

        for entry in std::fs::read_dir(&self.output_dir)? {
            let entry = entry?;
            let path = entry.path();
            
            if let Some(file_name) = path.file_name().and_then(|n| n.to_str()) {
                if file_name.starts_with("memscope_thread_") && file_name.ends_with(".bin") {
                    // Extract thread ID from filename
                    let thread_id_str = file_name
                        .strip_prefix("memscope_thread_")
                        .and_then(|s| s.strip_suffix(".bin"))
                        .ok_or("Invalid thread file name format")?;
                    
                    let thread_id: u64 = thread_id_str.parse()?;
                    
                    let freq_file = path.with_extension("freq");
                    if freq_file.exists() {
                        files.push((thread_id, path, freq_file));
                    }
                }
            }
        }
        
        Ok(files)
    }

    /// Parse event file and return all events
    fn parse_event_file(&self, file_path: &Path) -> Result<Vec<Event>, Box<dyn std::error::Error>> {
        let file_content = std::fs::read(file_path)?;
        let mut events = Vec::new();
        let mut offset = 0;

        // Read length-prefixed chunks
        while offset + 4 <= file_content.len() {
            // Read length (4 bytes, little endian)
            let length_bytes = &file_content[offset..offset + 4];
            let length = u32::from_le_bytes([length_bytes[0], length_bytes[1], length_bytes[2], length_bytes[3]]) as usize;
            offset += 4;

            if offset + length > file_content.len() {
                break; // Incomplete chunk
            }

            // Deserialize events chunk
            let chunk_data = &file_content[offset..offset + length];
            let chunk_events: Vec<Event> = postcard::from_bytes(chunk_data)?;
            events.extend(chunk_events);
            offset += length;
        }

        Ok(events)
    }

    /// Parse frequency file
    fn parse_frequency_file(&self, file_path: &Path) -> Result<Vec<FrequencyData>, Box<dyn std::error::Error>> {
        let file_content = std::fs::read(file_path)?;
        let frequencies: Vec<FrequencyData> = postcard::from_bytes(&file_content)?;
        Ok(frequencies)
    }

    /// Analyze single thread data and convert Event to AllocationEvent
    fn analyze_thread_data(&self, thread_id: u64, events: Vec<Event>, frequencies: Vec<FrequencyData>) -> Result<ThreadStats, Box<dyn std::error::Error>> {
        let mut allocations = 0u64;
        let mut deallocations = 0u64;
        let mut current_memory = 0usize;
        let mut peak_memory = 0usize;
        let mut total_allocated = 0usize;
        let mut allocation_sizes = Vec::new();

        // Process events chronologically
        let mut sorted_events = events;
        sorted_events.sort_by_key(|e| e.timestamp);

        for event in &sorted_events {
            match event.event_type {
                EventType::Allocation => {
                    allocations += 1;
                    current_memory += event.size;
                    total_allocated += event.size;
                    allocation_sizes.push(event.size);
                    peak_memory = peak_memory.max(current_memory);
                }
                EventType::Deallocation => {
                    deallocations += 1;
                    // Note: We don't track exact deallocation sizes in current implementation
                    // This could be enhanced by tracking allocation->deallocation mapping
                }
            }
        }

        let avg_allocation_size = if !allocation_sizes.is_empty() {
            allocation_sizes.iter().sum::<usize>() as f64 / allocation_sizes.len() as f64
        } else {
            0.0
        };

        // Build frequency map from frequency data
        let allocation_frequency: HashMap<u64, u64> = frequencies
            .into_iter()
            .map(|f| (f.call_stack_hash, f.frequency))
            .collect();

        // Convert Event to AllocationEvent for analysis compatibility
        let timeline: Vec<AllocationEvent> = sorted_events.into_iter().map(|event| {
            AllocationEvent {
                timestamp: event.timestamp,
                ptr: event.ptr,
                size: event.size,
                call_stack_hash: event.call_stack_hash,
                event_type: event.event_type,
                thread_id: event.thread_id,
            }
        }).collect();

        Ok(ThreadStats {
            thread_id,
            total_allocations: allocations,
            total_deallocations: deallocations,
            peak_memory,
            total_allocated,
            allocation_frequency,
            avg_allocation_size,
            timeline,
        })
    }

    /// Find hottest call stacks across all threads
    fn find_hottest_call_stacks(&self, thread_stats: &HashMap<u64, ThreadStats>) -> Vec<(u64, u64, usize)> {
        let mut call_stack_totals: HashMap<u64, (u64, usize)> = HashMap::new();

        for stats in thread_stats.values() {
            for (&hash, &frequency) in &stats.allocation_frequency {
                let entry = call_stack_totals.entry(hash).or_insert((0, 0));
                entry.0 += frequency;
                // Estimate total size (this could be more accurate with better tracking)
                entry.1 += (stats.avg_allocation_size as usize) * frequency as usize;
            }
        }

        let mut hottest: Vec<(u64, u64, usize)> = call_stack_totals
            .into_iter()
            .map(|(hash, (freq, size))| (hash, freq, size))
            .collect();

        // Sort by frequency * size to find most impactful call stacks
        hottest.sort_by(|a, b| (b.1 * b.2 as u64).cmp(&(a.1 * a.2 as u64)));
        hottest.truncate(50); // Top 50 hottest call stacks

        hottest
    }

    /// Analyze interactions between threads
    fn analyze_thread_interactions(&self, thread_stats: &HashMap<u64, ThreadStats>) -> Vec<ThreadInteraction> {
        let mut interactions = Vec::new();

        // Simple heuristic: threads that allocate in similar memory regions might be interacting
        let thread_ids: Vec<u64> = thread_stats.keys().copied().collect();

        for i in 0..thread_ids.len() {
            for j in i + 1..thread_ids.len() {
                let thread_a = thread_ids[i];
                let thread_b = thread_ids[j];

                let stats_a = &thread_stats[&thread_a];
                let stats_b = &thread_stats[&thread_b];

                // Check for shared allocation patterns (simplified)
                let mut shared_regions = Vec::new();
                let mut interaction_count = 0u64;

                // Find common call stack patterns (indicating similar allocation patterns)
                for (&hash_a, &freq_a) in &stats_a.allocation_frequency {
                    if let Some(&freq_b) = stats_b.allocation_frequency.get(&hash_a) {
                        interaction_count += freq_a.min(freq_b);
                        // Use call stack hash as proxy for shared pattern
                        shared_regions.push(hash_a);
                    }
                }

                if interaction_count > 0 {
                    interactions.push(ThreadInteraction {
                        thread_a,
                        thread_b,
                        shared_patterns: shared_regions,
                        interaction_strength: interaction_count,
                        interaction_type: InteractionType::SimilarPatterns,
                    });
                }
            }
        }

        // Sort by interaction strength
        interactions.sort_by(|a, b| b.interaction_strength.cmp(&a.interaction_strength));
        interactions
    }

    /// Find memory usage peaks across all threads
    fn find_memory_peaks(&self, thread_stats: &HashMap<u64, ThreadStats>) -> Vec<MemoryPeak> {
        let mut peaks = Vec::new();

        for stats in thread_stats.values() {
            let mut current_memory = 0usize;
            let mut current_allocations = 0u64;

            for event in &stats.timeline {
                match event.event_type {
                    EventType::Allocation => {
                        current_memory += event.size;
                        current_allocations += 1;

                        // Record peak if it's significant
                        if current_memory > 1024 * 1024 { // > 1MB
                            peaks.push(MemoryPeak {
                                timestamp: event.timestamp,
                                thread_id: stats.thread_id,
                                memory_usage: current_memory,
                                active_allocations: current_allocations,
                                triggering_call_stack: event.call_stack_hash,
                            });
                        }
                    }
                    EventType::Deallocation => {
                        current_allocations = current_allocations.saturating_sub(1);
                        // Note: memory tracking for deallocation would need size info
                    }
                }
            }
        }

        // Sort by memory usage
        peaks.sort_by(|a, b| b.memory_usage.cmp(&a.memory_usage));
        peaks.truncate(100); // Top 100 peaks

        peaks
    }

    /// Detect performance bottlenecks
    fn detect_performance_bottlenecks(&self, thread_stats: &HashMap<u64, ThreadStats>) -> Vec<PerformanceBottleneck> {
        let mut bottlenecks = Vec::new();

        for stats in thread_stats.values() {
            // Detect high-frequency small allocations
            for (&hash, &frequency) in &stats.allocation_frequency {
                if frequency > 1000 && stats.avg_allocation_size < 1024.0 {
                    bottlenecks.push(PerformanceBottleneck {
                        bottleneck_type: BottleneckType::HighFrequencySmallAllocation,
                        thread_id: stats.thread_id,
                        call_stack_hash: hash,
                        severity: (frequency as f64 / 10000.0).min(1.0),
                        description: format!("High frequency ({}) small allocations (avg {}B) in thread {}", 
                                           frequency, stats.avg_allocation_size as usize, stats.thread_id),
                        suggestion: "Consider using memory pools or batch allocation strategies".to_string(),
                    });
                }
            }

            // Detect potential memory leaks
            if stats.total_deallocations == 0 && stats.total_allocations > 100 {
                bottlenecks.push(PerformanceBottleneck {
                    bottleneck_type: BottleneckType::MemoryLeak,
                    thread_id: stats.thread_id,
                    call_stack_hash: 0, // General thread issue
                    severity: 0.8,
                    description: format!("Potential memory leak: {} allocations, 0 deallocations in thread {}", 
                                       stats.total_allocations, stats.thread_id),
                    suggestion: "Review deallocation logic and consider using RAII patterns".to_string(),
                });
            }

            // Detect large allocation spikes
            if stats.peak_memory > 100 * 1024 * 1024 { // > 100MB
                bottlenecks.push(PerformanceBottleneck {
                    bottleneck_type: BottleneckType::LargeAllocationSpike,
                    thread_id: stats.thread_id,
                    call_stack_hash: 0,
                    severity: (stats.peak_memory as f64 / (1024.0 * 1024.0 * 1024.0)).min(1.0), // Severity based on GB
                    description: format!("Large memory spike: {}MB peak in thread {}", 
                                       stats.peak_memory / (1024 * 1024), stats.thread_id),
                    suggestion: "Consider streaming or chunked processing for large data sets".to_string(),
                });
            }
        }

        // Sort by severity
        bottlenecks.sort_by(|a, b| b.severity.partial_cmp(&a.severity).unwrap_or(std::cmp::Ordering::Equal));
        bottlenecks
    }

    /// Export aggregated analysis to JSON
    pub fn export_analysis(&self, analysis: &LockfreeAnalysis, output_path: &Path) -> Result<(), Box<dyn std::error::Error>> {
        let json_content = serde_json::to_string_pretty(analysis)?;
        std::fs::write(output_path, json_content)?;
        Ok(())
    }

    /// Generate comprehensive HTML report
    pub fn generate_html_report(&self, analysis: &LockfreeAnalysis, output_path: &Path) -> Result<(), Box<dyn std::error::Error>> {
        let html_content = self.build_html_report(analysis)?;
        std::fs::write(output_path, html_content)?;
        Ok(())
    }

    fn build_html_report(&self, analysis: &LockfreeAnalysis) -> Result<String, Box<dyn std::error::Error>> {
        // Use the new enhanced visualizer
        use super::visualizer::generate_enhanced_html_report;
        
        // Create a temporary file to get the content
        let temp_path = std::env::temp_dir().join("temp_report.html");
        generate_enhanced_html_report(analysis, &temp_path)?;
        let content = std::fs::read_to_string(&temp_path)?;
        let _ = std::fs::remove_file(&temp_path); // Cleanup
        
        Ok(content)
    }

    fn build_html_report_legacy(&self, analysis: &LockfreeAnalysis) -> Result<String, Box<dyn std::error::Error>> {
        let mut html = String::new();
        
        // Enhanced HTML with modern styling and comprehensive data display
        html.push_str(r#"<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Multi-threaded Memory Analysis Report</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        .container { 
            max-width: 1400px; 
            margin: 0 auto; 
            background: white; 
            border-radius: 15px; 
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        .header { 
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%); 
            color: white; 
            padding: 30px; 
            text-align: center; 
        }
        .header h1 { font-size: 2.5em; margin-bottom: 10px; }
        .header .subtitle { font-size: 1.2em; opacity: 0.9; }
        .content { padding: 30px; }
        .section { 
            margin-bottom: 40px; 
            background: #f8f9fa; 
            border-radius: 10px; 
            padding: 25px; 
            box-shadow: 0 5px 15px rgba(0,0,0,0.05);
        }
        .section h2 { 
            color: #2c3e50; 
            border-bottom: 3px solid #3498db; 
            padding-bottom: 10px; 
            margin-bottom: 20px; 
            font-size: 1.8em;
        }
        .stats-grid { 
            display: grid; 
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); 
            gap: 20px; 
            margin-bottom: 30px;
        }
        .stat-card { 
            background: white; 
            border-radius: 10px; 
            padding: 20px; 
            border-left: 5px solid #3498db;
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
        }
        .stat-number { font-size: 2em; font-weight: bold; color: #2c3e50; }
        .stat-label { color: #7f8c8d; font-size: 0.9em; }
        .thread-detail { 
            background: white; 
            border-radius: 10px; 
            padding: 20px; 
            margin: 15px 0; 
            border-left: 5px solid #e74c3c;
            box-shadow: 0 3px 10px rgba(0,0,0,0.05);
        }
        .thread-header { 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            margin-bottom: 15px;
        }
        .thread-title { color: #2c3e50; font-size: 1.4em; font-weight: bold; }
        .thread-id { background: #3498db; color: white; padding: 5px 10px; border-radius: 15px; }
        .metric-row { 
            display: grid; 
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); 
            gap: 15px; 
            margin: 10px 0;
        }
        .metric { text-align: center; }
        .metric-value { font-size: 1.3em; font-weight: bold; color: #27ae60; }
        .metric-name { font-size: 0.9em; color: #7f8c8d; }
        .enhanced-table { 
            width: 100%; 
            border-collapse: collapse; 
            background: white; 
            border-radius: 10px; 
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        .enhanced-table th { 
            background: linear-gradient(135deg, #3498db, #2980b9); 
            color: white; 
            padding: 15px; 
            text-align: left; 
            font-weight: 600;
        }
        .enhanced-table td { 
            padding: 12px 15px; 
            border-bottom: 1px solid #ecf0f1; 
        }
        .enhanced-table tr:hover { background: #ecf0f1; }
        .bottleneck { 
            background: linear-gradient(135deg, #fff5f5, #fed7d7); 
            border-left: 5px solid #e53e3e; 
            padding: 20px; 
            margin: 15px 0; 
            border-radius: 10px;
        }
        .bottleneck-header { 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            margin-bottom: 10px;
        }
        .severity-badge { 
            background: #e53e3e; 
            color: white; 
            padding: 5px 10px; 
            border-radius: 15px; 
            font-size: 0.8em;
        }
        .interaction { 
            background: linear-gradient(135deg, #ebf8ff, #bee3f8); 
            border-left: 5px solid #3182ce; 
            padding: 20px; 
            margin: 15px 0; 
            border-radius: 10px;
        }
        .tab-container { margin: 20px 0; }
        .tab-buttons { 
            display: flex; 
            background: #ecf0f1; 
            border-radius: 10px 10px 0 0; 
            overflow: hidden;
        }
        .tab-button { 
            background: #ecf0f1; 
            border: none; 
            padding: 15px 30px; 
            cursor: pointer; 
            transition: all 0.3s;
        }
        .tab-button.active { background: #3498db; color: white; }
        .tab-content { 
            background: white; 
            padding: 30px; 
            border-radius: 0 0 10px 10px; 
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        .progress-bar { 
            background: #ecf0f1; 
            height: 20px; 
            border-radius: 10px; 
            overflow: hidden; 
            margin: 10px 0;
        }
        .progress-fill { 
            background: linear-gradient(90deg, #27ae60, #2ecc71); 
            height: 100%; 
            transition: width 0.3s;
        }
        .call-stack-item { 
            background: #f8f9fa; 
            padding: 10px; 
            margin: 5px 0; 
            border-radius: 5px; 
            border-left: 3px solid #3498db;
        }
        .hash-code { 
            font-family: 'Courier New', monospace; 
            background: #2c3e50; 
            color: #ecf0f1; 
            padding: 2px 6px; 
            border-radius: 3px; 
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🚀 Enhanced Memory Analysis Report</h1>
            <div class="subtitle">Complete Multi-threaded Memory Tracking Analysis</div>
        </div>
        <div class="content">
"#);

        // Global Summary Section
        html.push_str(r#"<div class="section">
                <h2>📊 Executive Summary</h2>
                <div class="stats-grid">"#);
        
        html.push_str(&format!(r#"
                <div class="stat-card">
                    <div class="stat-number">{}</div>
                    <div class="stat-label">Threads Analyzed</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">{}</div>
                    <div class="stat-label">Total Allocations</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">{}</div>
                    <div class="stat-label">Total Deallocations</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">{:.1} MB</div>
                    <div class="stat-label">Peak Memory Usage</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">{}</div>
                    <div class="stat-label">Unique Call Stacks</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">{}</div>
                    <div class="stat-label">Thread Interactions</div>
                </div>"#,
            analysis.thread_stats.len(),
            analysis.summary.total_allocations,
            analysis.summary.total_deallocations,
            analysis.summary.peak_memory_usage as f64 / (1024.0 * 1024.0),
            analysis.summary.unique_call_stacks,
            analysis.thread_interactions.len()
        ));
        
        html.push_str("</div></div>");

        // Enhanced Thread Statistics
        html.push_str(r#"<div class="section">
                <h2>🧵 Detailed Thread Analysis</h2>"#);
        
        let mut sorted_threads: Vec<_> = analysis.thread_stats.iter().collect();
        sorted_threads.sort_by(|a, b| b.1.total_allocations.cmp(&a.1.total_allocations));
        
        for (thread_id, stats) in sorted_threads.iter().take(15) { // Show top 15 threads
            let efficiency = if stats.total_allocations > 0 {
                (stats.total_deallocations as f64 / stats.total_allocations as f64 * 100.0).min(100.0)
            } else {
                0.0
            };
            
            html.push_str(&format!(r#"
                <div class="thread-detail">
                    <div class="thread-header">
                        <div class="thread-title">Thread Analysis</div>
                        <div class="thread-id">ID: {}</div>
                    </div>
                    <div class="metric-row">
                        <div class="metric">
                            <div class="metric-value">{}</div>
                            <div class="metric-name">Allocations</div>
                        </div>
                        <div class="metric">
                            <div class="metric-value">{}</div>
                            <div class="metric-name">Deallocations</div>
                        </div>
                        <div class="metric">
                            <div class="metric-value">{:.1}%</div>
                            <div class="metric-name">Memory Efficiency</div>
                        </div>
                        <div class="metric">
                            <div class="metric-value">{:.1} MB</div>
                            <div class="metric-name">Peak Memory</div>
                        </div>
                        <div class="metric">
                            <div class="metric-value">{:.0} B</div>
                            <div class="metric-name">Avg Allocation</div>
                        </div>
                        <div class="metric">
                            <div class="metric-value">{}</div>
                            <div class="metric-name">Call Stack Patterns</div>
                        </div>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" style="width: {:.1}%"></div>
                    </div>
                </div>"#,
                thread_id,
                stats.total_allocations,
                stats.total_deallocations,
                efficiency,
                stats.peak_memory as f64 / (1024.0 * 1024.0),
                stats.avg_allocation_size,
                stats.allocation_frequency.len(),
                efficiency
            ));
        }
        
        html.push_str("</div>");

        // Performance Bottlenecks with Enhanced Display
        html.push_str(r#"<div class="section">
                <h2>⚠️ Performance Bottlenecks & Issues</h2>"#);
        
        if analysis.performance_bottlenecks.is_empty() {
            html.push_str(r#"<div style="text-align: center; padding: 40px; color: #27ae60;">
                    <h3>🎉 No Performance Bottlenecks Detected!</h3>
                    <p>Your application shows healthy memory allocation patterns.</p>
                </div>"#);
        } else {
            for bottleneck in &analysis.performance_bottlenecks {
                let severity_color = match bottleneck.severity {
                    s if s > 0.8 => "#e53e3e",
                    s if s > 0.5 => "#dd6b20", 
                    _ => "#f6ad55",
                };
                
                html.push_str(&format!(r#"
                    <div class="bottleneck">
                        <div class="bottleneck-header">
                            <h4>{:?}</h4>
                            <div class="severity-badge" style="background: {}">
                                Severity: {:.1}/1.0
                            </div>
                        </div>
                        <p><strong>Description:</strong> {}</p>
                        <p><strong>Thread:</strong> {}, <strong>Call Stack:</strong> <span class="hash-code">0x{:x}</span></p>
                        <p><strong>Recommendation:</strong> {}</p>
                    </div>"#,
                    bottleneck.bottleneck_type,
                    severity_color,
                    bottleneck.severity,
                    bottleneck.description,
                    bottleneck.thread_id,
                    bottleneck.call_stack_hash,
                    bottleneck.suggestion
                ));
            }
        }
        
        html.push_str("</div>");

        // Thread Interactions Analysis
        html.push_str(r#"<div class="section">
                <h2>🔗 Thread Interaction Analysis</h2>"#);
        
        if analysis.thread_interactions.is_empty() {
            html.push_str(r#"<div style="text-align: center; padding: 40px; color: #7f8c8d;">
                    <h3>No Thread Interactions Detected</h3>
                    <p>Threads are operating independently with minimal shared patterns.</p>
                </div>"#);
        } else {
            for interaction in analysis.thread_interactions.iter().take(10) {
                html.push_str(&format!(r#"
                    <div class="interaction">
                        <h4>Thread {} ↔ Thread {}</h4>
                        <div class="metric-row">
                            <div class="metric">
                                <div class="metric-value">{}</div>
                                <div class="metric-name">Interaction Strength</div>
                            </div>
                            <div class="metric">
                                <div class="metric-value">{}</div>
                                <div class="metric-name">Shared Patterns</div>
                            </div>
                            <div class="metric">
                                <div class="metric-value">{:?}</div>
                                <div class="metric-name">Interaction Type</div>
                            </div>
                        </div>
                        <p><strong>Shared Pattern Examples:</strong></p>"#,
                    interaction.thread_a,
                    interaction.thread_b,
                    interaction.interaction_strength,
                    interaction.shared_patterns.len(),
                    interaction.interaction_type
                ));
                
                for (i, pattern) in interaction.shared_patterns.iter().take(5).enumerate() {
                    html.push_str(&format!(
                        r#"<div class="call-stack-item">Pattern {}: <span class="hash-code">0x{:x}</span></div>"#,
                        i + 1, pattern
                    ));
                }
                
                html.push_str("</div>");
            }
        }
        
        html.push_str("</div>");

        // Hottest Call Stacks with Enhanced Table
        html.push_str(r#"<div class="section">
                <h2>🔥 Hottest Call Stack Analysis</h2>
                <p style="margin-bottom: 20px;">The most frequently used and impactful allocation patterns across all threads.</p>
                <table class="enhanced-table">
                    <thead>
                        <tr>
                            <th>Rank</th>
                            <th>Call Stack Hash</th>
                            <th>Frequency</th>
                            <th>Total Size</th>
                            <th>Impact Score</th>
                            <th>Avg Size</th>
                            <th>Performance Impact</th>
                        </tr>
                    </thead>
                    <tbody>"#);
        
        for (i, hot_stack) in analysis.hottest_call_stacks.iter().take(25).enumerate() {
            let avg_size = if hot_stack.total_frequency > 0 {
                hot_stack.total_size as f64 / hot_stack.total_frequency as f64
            } else {
                0.0
            };
            
            let impact_level = match hot_stack.impact_score {
                s if s > 1_000_000 => "🔴 Critical",
                s if s > 100_000 => "🟡 High", 
                s if s > 10_000 => "🟢 Medium",
                _ => "⚪ Low",
            };
            
            html.push_str(&format!(r#"
                        <tr>
                            <td><strong>{}</strong></td>
                            <td><span class="hash-code">0x{:x}</span></td>
                            <td>{}</td>
                            <td>{:.1} KB</td>
                            <td>{}</td>
                            <td>{:.0} B</td>
                            <td>{}</td>
                        </tr>"#,
                i + 1,
                hot_stack.call_stack_hash,
                hot_stack.total_frequency,
                hot_stack.total_size as f64 / 1024.0,
                hot_stack.impact_score,
                avg_size,
                impact_level
            ));
        }
        
        html.push_str("</tbody></table></div>");

        // Memory Peaks Analysis
        if !analysis.memory_peaks.is_empty() {
            html.push_str(r#"<div class="section">
                    <h2>📈 Memory Peak Analysis</h2>
                    <table class="enhanced-table">
                        <thead>
                            <tr>
                                <th>Timestamp</th>
                                <th>Thread ID</th>
                                <th>Memory Usage</th>
                                <th>Active Allocations</th>
                                <th>Triggering Call Stack</th>
                            </tr>
                        </thead>
                        <tbody>"#);
            
            for peak in analysis.memory_peaks.iter().take(15) {
                html.push_str(&format!(r#"
                            <tr>
                                <td>{}</td>
                                <td>{}</td>
                                <td>{:.2} MB</td>
                                <td>{}</td>
                                <td><span class="hash-code">0x{:x}</span></td>
                            </tr>"#,
                    peak.timestamp,
                    peak.thread_id,
                    peak.memory_usage as f64 / (1024.0 * 1024.0),
                    peak.active_allocations,
                    peak.triggering_call_stack
                ));
            }
            
            html.push_str("</tbody></table></div>");
        }

        // Footer with metadata
        html.push_str(&format!(r#"
            <div class="section" style="text-align: center; background: #f8f9fa; color: #7f8c8d;">
                <h3>📋 Report Metadata</h3>
                <p>Generated on: {}</p>
                <p>Analysis covered {} threads with {} total operations</p>
                <p>Memory efficiency: {:.1}% overall</p>
                <p>Data quality: {} unique call stack patterns detected</p>
            </div>
        </div>
    </div>
</body>
</html>"#,
            std::time::SystemTime::now().duration_since(std::time::UNIX_EPOCH).unwrap_or_default().as_secs(),
            analysis.thread_stats.len(),
            analysis.summary.total_allocations + analysis.summary.total_deallocations,
            if analysis.summary.total_allocations > 0 {
                analysis.summary.total_deallocations as f64 / analysis.summary.total_allocations as f64 * 100.0
            } else { 0.0 },
            analysis.summary.unique_call_stacks
        ));
        
        Ok(html)
    }
}