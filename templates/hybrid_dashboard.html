<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{TITLE}}</title>
    <style>
        /* CSS Variables for theming */
        :root {
            --primary: #3b82f6;
            --secondary: #64748b;
            --accent: #f59e0b;
            --warning: #f59e0b;
            --danger: #ef4444;
            --success: #10b981;
            --bg: #ffffff;
            --bg2: #f8fafc;
            --text: #1e293b;
            --text2: #64748b;
            --border: #e2e8f0;
        }

        [data-theme="dark"] {
            --primary: #60a5fa;
            --secondary: #94a3b8;
            --accent: #fbbf24;
            --warning: #fbbf24;
            --danger: #f87171;
            --success: #34d399;
            --bg: #0f172a;
            --bg2: #1e293b;
            --text: #f1f5f9;
            --text2: #94a3b8;
            --border: #334155;
        }

        * { 
            box-sizing: border-box; 
            margin: 0; 
            padding: 0; 
        }
        
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            background: var(--bg); 
            color: var(--text); 
            line-height: 1.6;
            transition: all 0.3s ease;
        }
        
        .container { 
            max-width: 1400px; 
            margin: 0 auto; 
            padding: 20px; 
        }
        
        .header { 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            margin-bottom: 30px; 
            padding: 20px; 
            background: var(--bg2); 
            border-radius: 12px; 
            border: 1px solid var(--border);
        }
        
        .header h1 { 
            color: var(--primary); 
            font-size: 2rem; 
            font-weight: 700; 
        }
        
        .controls { 
            display: flex; 
            gap: 12px; 
        }
        
        .btn { 
            padding: 8px 16px; 
            border: none; 
            border-radius: 8px; 
            cursor: pointer; 
            font-weight: 600; 
            transition: all 0.2s ease;
            background: var(--primary); 
            color: white;
        }
        
        .btn:hover { 
            transform: translateY(-1px); 
            box-shadow: 0 4px 8px rgba(0,0,0,0.1); 
        }
        
        .stats-grid { 
            display: grid; 
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); 
            gap: 20px; 
            margin-bottom: 30px; 
        }
        
        .stat-card { 
            background: var(--bg2); 
            padding: 20px; 
            border-radius: 12px; 
            border: 1px solid var(--border);
            transition: all 0.2s ease;
        }
        
        .stat-card:hover { 
            transform: translateY(-2px); 
            box-shadow: 0 8px 16px rgba(0,0,0,0.1); 
        }
        
        .stat-value { 
            font-size: 2rem; 
            font-weight: 700; 
            margin-bottom: 8px; 
        }
        
        .stat-label { 
            color: var(--text2); 
            font-size: 0.9rem; 
        }
        
        .section { 
            background: var(--bg2); 
            padding: 24px; 
            border-radius: 12px; 
            margin-bottom: 24px; 
            border: 1px solid var(--border);
        }
        
        .section h3 { 
            margin-bottom: 20px; 
            color: var(--primary); 
            font-size: 1.4rem; 
            font-weight: 600; 
        }
        
        .variables-grid { 
            display: grid; 
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); 
            gap: 16px; 
        }
        
        .variable-card { 
            background: var(--bg); 
            padding: 16px; 
            border-radius: 8px; 
            border: 1px solid var(--border);
            cursor: pointer; 
            transition: all 0.2s ease;
        }
        
        .variable-card:hover { 
            transform: translateY(-1px); 
            box-shadow: 0 4px 8px rgba(0,0,0,0.1); 
        }
        
        .variable-name { 
            font-weight: 600; 
            margin-bottom: 8px; 
        }
        
        .variable-info { 
            display: flex; 
            justify-content: space-between; 
            color: var(--text2); 
            font-size: 0.9rem; 
        }
        
        .status-active { color: var(--success); }
        .status-allocated { color: var(--warning); }
        .status-shared { color: var(--primary); }
        .status-deallocated { color: var(--text2); }
        
        .modal { 
            display: none; 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            background: rgba(0,0,0,0.5); 
            z-index: 1000; 
        }
        
        .modal-content { 
            position: absolute; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%); 
            background: var(--bg); 
            padding: 24px; 
            border-radius: 12px; 
            max-width: 600px; 
            width: 90%; 
            max-height: 80vh; 
            overflow-y: auto; 
        }
        
        .close { 
            position: absolute; 
            top: 12px; 
            right: 20px; 
            font-size: 24px; 
            cursor: pointer; 
            color: var(--text2); 
        }
        
        .drill-down-content h4 { 
            margin-bottom: 16px; 
            color: var(--primary); 
        }
        
        .metric-row, .pattern-row { 
            display: flex; 
            justify-content: space-between; 
            padding: 8px 0; 
            border-bottom: 1px solid var(--border); 
        }
        
        .recommendations, .optimization-tips { 
            margin-top: 16px; 
        }
        
        .rec-item, .tip-item { 
            display: flex; 
            gap: 12px; 
            padding: 8px; 
            margin: 8px 0; 
            background: var(--bg2); 
            border-radius: 6px; 
        }
        
        .rec-priority, .tip-priority { 
            padding: 2px 8px; 
            border-radius: 4px; 
            font-size: 0.8rem; 
            font-weight: 600; 
        }
        
        .rec-priority.high, .tip-priority.high { 
            background: var(--danger); 
            color: white; 
        }
        
        .rec-priority.medium, .tip-priority.medium { 
            background: var(--warning); 
            color: white; 
        }
        
        .rec-priority.low, .tip-priority.low { 
            background: var(--success); 
            color: white; 
        }

        /* FFI Crossing Visualization */
        .ffi-crossing-section { 
            background: var(--bg2); 
            border-radius: 8px; 
            padding: 16px; 
            margin-bottom: 20px; 
            border-left: 4px solid var(--warning); 
        }
        
        .ffi-swimlane { 
            display: flex; 
            align-items: center; 
            gap: 12px; 
            margin: 16px 0; 
            padding: 12px; 
            background: var(--bg); 
            border-radius: 8px; 
        }
        
        .ffi-lane { 
            flex: 1; 
            text-align: center; 
            padding: 12px; 
            border-radius: 6px; 
        }
        
        .rust-lane { 
            background: linear-gradient(135deg, #f97316, #ea580c); 
            color: white; 
        }
        
        .c-lane { 
            background: linear-gradient(135deg, #6b7280, #4b5563); 
            color: white; 
        }
        
        .lane-label { 
            font-size: 12px; 
            font-weight: 600; 
            margin-bottom: 4px; 
        }
        
        .ffi-event { 
            font-size: 14px; 
        }
        
        .ffi-boundary { 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            gap: 4px; 
        }
        
        .boundary-arrow { 
            font-size: 20px; 
            font-weight: bold; 
            color: var(--warning); 
        }
        
        .boundary-label { 
            font-size: 10px; 
            color: var(--text2); 
            font-weight: 600; 
        }
        
        .ffi-warning { 
            display: flex; 
            align-items: center; 
            gap: 8px; 
            background: rgba(245, 158, 11, 0.1); 
            padding: 8px 12px; 
            border-radius: 6px; 
            margin-top: 12px; 
        }
        
        .warning-icon { 
            font-size: 16px; 
        }
        
        .warning-text { 
            font-size: 14px; 
            color: var(--warning); 
            font-weight: 600; 
        }

        /* Attribution Panel Styles */
        .attribution-panel {
            animation: slideInFromTop 0.3s ease;
        }

        .attribution-section {
            background: var(--bg2);
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 20px;
        }

        .attribution-summary {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .hotspot-indicator {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .hotspot-badge {
            padding: 6px 12px;
            border-radius: 20px;
            color: white;
            font-size: 0.85rem;
            font-weight: 600;
        }

        .hotspot-desc {
            color: var(--text2);
            font-size: 0.9rem;
        }

        .attribution-actions {
            display: flex;
            gap: 8px;
        }

        .btn-secondary {
            padding: 6px 12px;
            border: 1px solid var(--border);
            background: var(--bg);
            color: var(--text);
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.2s ease;
        }

        .btn-secondary:hover {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        .contributors-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .contributor-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: var(--bg);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .contributor-item:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .contributor-rank {
            font-weight: 700;
            color: var(--primary);
            min-width: 30px;
        }

        .contributor-name {
            flex: 1;
            font-weight: 600;
        }

        .contributor-impact {
            color: var(--text2);
            font-size: 0.9rem;
        }

        .contributor-action {
            color: var(--primary);
            font-size: 0.85rem;
        }

        /* Inspector Modal Styles */
        .inspector-container {
            max-width: 800px;
            width: 100%;
        }

        .inspector-header h3 {
            margin-bottom: 16px;
            color: var(--primary);
        }

        .inspector-tabs {
            display: flex;
            gap: 4px;
            border-bottom: 2px solid var(--border);
            margin-bottom: 20px;
        }

        .inspector-tab {
            padding: 10px 16px;
            border: none;
            background: transparent;
            color: var(--text2);
            cursor: pointer;
            border-radius: 6px 6px 0 0;
            transition: all 0.2s ease;
        }

        .inspector-tab.active {
            background: var(--primary);
            color: white;
        }

        .inspector-tab:hover:not(.active) {
            background: var(--bg2);
            color: var(--text);
        }

        .inspector-content {
            min-height: 400px;
        }

        .inspector-page {
            display: none;
        }

        .inspector-page.active {
            display: block;
        }

        .lifecycle-timeline {
            background: var(--bg2);
            padding: 16px;
            border-radius: 8px;
        }

        .timeline-events {
            display: flex;
            justify-content: space-between;
            margin-bottom: 16px;
        }

        .timeline-event {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            padding: 8px;
            border-radius: 6px;
            min-width: 80px;
        }

        .timeline-event.allocated {
            background: rgba(245, 158, 11, 0.1);
        }

        .timeline-event.active {
            background: rgba(16, 185, 129, 0.1);
        }

        .timeline-event.shared {
            background: rgba(59, 130, 246, 0.1);
        }

        .event-time {
            font-size: 0.8rem;
            color: var(--text2);
        }

        .event-label {
            font-size: 0.9rem;
            font-weight: 600;
        }

        .event-details {
            font-size: 0.75rem;
            color: var(--text2);
            text-align: center;
        }

        .thread-metrics .metric-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 16px;
            margin-bottom: 20px;
        }

        .metric-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 16px;
            background: var(--bg2);
            border-radius: 8px;
        }

        .metric-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--primary);
        }

        .metric-label {
            font-size: 0.85rem;
            color: var(--text2);
            margin-top: 4px;
        }

        .task-items, .variables-table-content, .task-variables-content {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .task-item, .var-row {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: var(--bg2);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .task-item:hover, .var-row:hover {
            background: var(--primary);
            color: white;
        }

        .task-id, .var-name {
            font-weight: 600;
            flex: 1;
        }

        .task-status, .var-status, .var-lifecycle {
            font-size: 0.85rem;
            padding: 2px 8px;
            border-radius: 12px;
            background: var(--success);
            color: white;
        }

        .task-memory, .var-size {
            font-size: 0.9rem;
            color: var(--text2);
        }

        .variable-search input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid var(--border);
            border-radius: 6px;
            margin-bottom: 16px;
        }

        .optimization-recommendations {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .rec-item.priority-high {
            border-left: 4px solid var(--danger);
        }

        .rec-item.priority-medium {
            border-left: 4px solid var(--warning);
        }

        .rec-impact {
            font-size: 0.85rem;
            color: var(--success);
            font-weight: 600;
        }

        .task-basic-info {
            background: var(--bg2);
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 16px;
        }

        .task-basic-info p {
            margin-bottom: 8px;
        }

        .optimization-report {
            background: var(--bg2);
            padding: 16px;
            border-radius: 8px;
            border-left: 4px solid var(--success);
        }

        .report-summary p {
            margin-bottom: 8px;
        }

        @keyframes slideInFromTop {
            from {
                transform: translateY(-20px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        /* Enhanced Diagnostics Styles */
        .diagnostics-section {
            border-left: 4px solid #8b5cf6;
        }

        .diagnostics-description, .layout-description {
            background: rgba(59, 130, 246, 0.1);
            padding: 12px 16px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid var(--primary);
        }

        .diagnostics-description p, .layout-description p {
            margin: 0 0 6px 0;
            font-size: 0.9rem;
        }

        .diagnostics-controls {
            display: flex;
            gap: 12px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .active-problems {
            min-height: 200px;
        }

        .no-problems {
            padding: 20px;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 16px;
            background: var(--bg);
            padding: 20px;
            border-radius: 12px;
            border: 2px solid var(--success);
            margin-bottom: 20px;
        }

        .status-icon {
            font-size: 2rem;
        }

        .status-text h4 {
            margin: 0 0 8px 0;
            color: var(--success);
        }

        .status-text p {
            margin: 0 0 6px 0;
            font-size: 1rem;
        }

        .status-text small {
            color: var(--text2);
            font-size: 0.85rem;
        }

        .quick-insights {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 16px;
        }

        .insight-card {
            display: flex;
            align-items: center;
            gap: 12px;
            background: var(--bg);
            padding: 16px;
            border-radius: 8px;
            border-left: 3px solid var(--primary);
        }

        .insight-icon {
            font-size: 1.5rem;
        }

        .insight-card strong {
            display: block;
            margin-bottom: 4px;
            color: var(--text);
        }

        .insight-card p {
            margin: 0;
            color: var(--text2);
            font-size: 0.9rem;
        }

        /* Code Health Summary Styles */
        .code-health-summary {
            background: var(--bg);
            border-radius: 12px;
            padding: 20px;
            border: 2px solid var(--success);
        }

        .health-header h4 {
            margin: 0 0 8px 0;
            color: var(--success);
        }

        .health-header p {
            margin: 0 0 16px 0;
            color: var(--text2);
        }

        .health-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
        }

        .health-metric {
            display: flex;
            align-items: center;
            gap: 12px;
            background: var(--bg2);
            padding: 16px;
            border-radius: 8px;
        }

        .metric-icon {
            font-size: 1.5rem;
        }

        .health-metric strong {
            display: block;
            margin-bottom: 4px;
            color: var(--text);
        }

        .health-metric p {
            margin: 0;
            color: var(--text2);
            font-size: 0.9rem;
        }

        /* FFI Analysis Styles */
        .ffi-explanation {
            background: rgba(245, 158, 11, 0.1);
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid var(--warning);
        }

        .ffi-explanation p {
            margin: 0 0 8px 0;
            font-size: 0.9rem;
        }

        .ffi-safety-checklist {
            background: var(--bg2);
            padding: 16px;
            border-radius: 8px;
            margin-top: 20px;
        }

        .ffi-safety-checklist h5 {
            margin: 0 0 12px 0;
            color: var(--primary);
        }

        .checklist-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 8px 0;
            border-bottom: 1px solid var(--border);
        }

        .checklist-item:last-child {
            border-bottom: none;
        }

        .check-status {
            font-size: 1.2rem;
            min-width: 24px;
        }

        /* Enhanced FFI Analysis Styles */
        .ffi-crossing-log, .ffi-memory-trace, .ffi-warnings {
            background: var(--bg2);
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 16px;
        }

        .ffi-crossing-log h5, .ffi-memory-trace h5, .ffi-warnings h5 {
            margin: 0 0 12px 0;
            color: var(--primary);
        }

        .crossing-timeline {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .crossing-event {
            display: grid;
            grid-template-columns: 60px 1fr 120px 200px;
            gap: 12px;
            align-items: center;
            padding: 8px;
            background: var(--bg);
            border-radius: 6px;
            font-size: 0.85rem;
        }

        .event-time {
            font-weight: 600;
            color: var(--text2);
        }

        .event-type.rust {
            color: #f97316;
            font-weight: 600;
        }

        .event-type.c {
            color: #6b7280;
            font-weight: 600;
        }

        .event-type.ffi {
            color: var(--warning);
            font-weight: 600;
        }

        .event-location {
            font-family: 'Courier New', monospace;
            color: var(--text2);
            font-size: 0.8rem;
        }

        .event-details {
            color: var(--text);
        }

        .memory-changes {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .memory-change {
            display: grid;
            grid-template-columns: 100px 1fr 80px;
            gap: 12px;
            align-items: center;
            padding: 8px;
            background: var(--bg);
            border-radius: 6px;
        }

        .change-side.rust {
            background: rgba(249, 115, 22, 0.1);
            color: #f97316;
            padding: 4px 8px;
            border-radius: 4px;
            font-weight: 600;
            font-size: 0.8rem;
        }

        .change-side.c {
            background: rgba(107, 114, 128, 0.1);
            color: #6b7280;
            padding: 4px 8px;
            border-radius: 4px;
            font-weight: 600;
            font-size: 0.8rem;
        }

        .change-action {
            font-size: 0.9rem;
        }

        .change-size {
            font-weight: 600;
            text-align: right;
        }

        .warning-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 8px;
        }

        .warning-item.warning-high {
            background: rgba(220, 38, 38, 0.1);
            border-left: 3px solid #dc2626;
        }

        .warning-item.warning-medium {
            background: rgba(245, 158, 11, 0.1);
            border-left: 3px solid var(--warning);
        }

        .warning-item.warning-low {
            background: rgba(34, 197, 94, 0.1);
            border-left: 3px solid var(--success);
        }

        .warning-icon {
            font-size: 1.2rem;
        }

        .warning-text {
            font-size: 0.9rem;
        }

        /* Call Stack Attribution Styles */
        .code-attribution-section {
            background: var(--bg2);
            padding: 16px;
            border-radius: 8px;
            margin-top: 20px;
            border-left: 4px solid var(--primary);
        }

        .code-attribution-section h5 {
            margin: 0 0 16px 0;
            color: var(--primary);
        }

        .stack-attribution-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .stack-item {
            background: var(--bg);
            border-radius: 8px;
            padding: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            border-left: 4px solid transparent;
        }

        .stack-item:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .stack-item.high {
            border-left-color: #dc2626;
        }

        .stack-item.medium {
            border-left-color: var(--warning);
        }

        .stack-item.low {
            border-left-color: var(--success);
        }

        .stack-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .function-info {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .function-name {
            font-weight: 600;
            font-family: 'Courier New', monospace;
            color: var(--text);
        }

        .file-location {
            font-size: 0.8rem;
            color: var(--text2);
            font-family: 'Courier New', monospace;
        }

        .allocation-stats {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 2px;
        }

        .allocation-percent {
            font-weight: 700;
            font-size: 1.1rem;
            color: var(--primary);
        }

        .allocation-size {
            font-size: 0.9rem;
            color: var(--text2);
        }

        .allocation-bar {
            height: 6px;
            background: var(--border);
            border-radius: 3px;
            overflow: hidden;
            margin-bottom: 8px;
        }

        .bar-fill {
            height: 100%;
            transition: width 0.3s ease;
        }

        .bar-fill.high {
            background: #dc2626;
        }

        .bar-fill.medium {
            background: var(--warning);
        }

        .bar-fill.low {
            background: var(--success);
        }

        .stack-details {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.85rem;
        }

        .call-count {
            color: var(--text2);
        }

        .action-hint {
            color: var(--primary);
            font-weight: 500;
        }

        /* Function Analysis Styles */
        .function-analysis {
            max-width: 800px;
        }

        .function-location {
            background: var(--bg2);
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .function-location p {
            margin: 0 0 6px 0;
        }

        .allocation-patterns {
            margin-bottom: 20px;
        }

        .pattern-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 16px;
            margin-top: 12px;
        }

        .pattern-item {
            background: var(--bg2);
            padding: 12px;
            border-radius: 6px;
            text-align: center;
        }

        .pattern-label {
            display: block;
            font-size: 0.8rem;
            color: var(--text2);
            margin-bottom: 4px;
        }

        .pattern-value {
            display: block;
            font-weight: 700;
            font-size: 1.1rem;
            margin-bottom: 4px;
        }

        .pattern-trend {
            font-size: 0.8rem;
        }

        .code-hotspots {
            margin-bottom: 20px;
        }

        .hotspot-lines {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 12px;
        }

        .hotspot-line {
            display: grid;
            grid-template-columns: 80px 1fr 120px;
            gap: 12px;
            align-items: center;
            padding: 8px;
            border-radius: 6px;
            font-size: 0.9rem;
        }

        .hotspot-line.high {
            background: rgba(220, 38, 38, 0.1);
        }

        .hotspot-line.medium {
            background: rgba(245, 158, 11, 0.1);
        }

        .hotspot-line.low {
            background: rgba(34, 197, 94, 0.1);
        }

        .line-number {
            font-family: 'Courier New', monospace;
            font-weight: 600;
            color: var(--text2);
        }

        .line-code {
            font-family: 'Courier New', monospace;
            color: var(--text);
        }

        .line-impact {
            text-align: right;
            font-weight: 600;
            font-size: 0.85rem;
        }

        .suggestion-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-top: 12px;
        }

        .suggestion-item {
            display: flex;
            gap: 12px;
            padding: 16px;
            background: var(--bg2);
            border-radius: 8px;
        }

        .suggestion-item.priority-high {
            border-left: 4px solid #dc2626;
        }

        .suggestion-item.priority-medium {
            border-left: 4px solid var(--warning);
        }

        .suggestion-icon {
            font-size: 1.5rem;
        }

        .suggestion-content strong {
            display: block;
            margin-bottom: 6px;
            color: var(--text);
        }

        .suggestion-content p {
            margin: 0 0 6px 0;
            color: var(--text2);
            font-size: 0.9rem;
        }

        .expected-impact {
            font-size: 0.85rem;
            color: var(--success);
            font-weight: 600;
        }

        /* Variable Controls and Legend Styles */
        .variables-controls {
            background: var(--bg2);
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .variable-legend h5 {
            margin: 0 0 12px 0;
            color: var(--primary);
        }

        .legend-items {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-bottom: 16px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 10px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            background: var(--bg);
            border: 2px solid transparent;
        }

        .legend-item:hover {
            background: var(--primary);
            color: white;
        }

        .legend-item.active {
            border-color: var(--primary);
            background: rgba(59, 130, 246, 0.1);
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 3px;
            border: 2px solid;
        }

        .legend-color.cpu-intensive {
            background: #fbbf24;
            border-color: #f59e0b;
        }

        .legend-color.io-intensive {
            background: #fb923c;
            border-color: #ea580c;
        }

        .legend-color.memory-intensive {
            background: #f87171;
            border-color: #dc2626;
        }

        .legend-color.async-heavy {
            background: #a78bfa;
            border-color: #8b5cf6;
        }

        .legend-color.normal {
            background: #94a3b8;
            border-color: #64748b;
        }

        .legend-color.all {
            background: linear-gradient(45deg, #fbbf24, #fb923c, #f87171, #a78bfa);
            border-color: var(--primary);
        }

        .variable-filters {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .filter-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .filter-group label {
            font-weight: 600;
            color: var(--text);
            font-size: 0.9rem;
        }

        .filter-group select {
            padding: 6px 10px;
            border: 1px solid var(--border);
            border-radius: 6px;
            background: var(--bg);
            color: var(--text);
        }

        /* Performance Category Variable Cards */
        .variable-card.cpu-intensive {
            border-left: 4px solid #f59e0b;
            background: rgba(251, 191, 36, 0.05);
        }

        .variable-card.io-intensive {
            border-left: 4px solid #ea580c;
            background: rgba(251, 146, 60, 0.05);
        }

        .variable-card.memory-intensive {
            border-left: 4px solid #dc2626;
            background: rgba(248, 113, 113, 0.05);
        }

        .variable-card.async-heavy {
            border-left: 4px solid #8b5cf6;
            background: rgba(167, 139, 250, 0.05);
        }

        .variable-card.normal {
            border-left: 4px solid #64748b;
            background: rgba(148, 163, 184, 0.05);
        }

        .performance-indicator {
            position: absolute;
            top: 8px;
            right: 8px;
        }

        .perf-badge {
            font-size: 0.7rem;
            font-weight: 600;
            padding: 2px 6px;
            border-radius: 4px;
            color: white;
        }

        .perf-badge.cpu-intensive {
            background: #f59e0b;
        }

        .perf-badge.io-intensive {
            background: #ea580c;
        }

        .perf-badge.memory-intensive {
            background: #dc2626;
        }

        .perf-badge.async-heavy {
            background: #8b5cf6;
        }

        .perf-badge.normal {
            background: #64748b;
        }

        .variable-card {
            position: relative;
        }

        .variable-card.filtered-out {
            display: none;
        }

        .problem-card {
            background: var(--bg);
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 12px;
            border-left: 4px solid;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .problem-card:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .problem-card.critical {
            border-color: #dc2626;
            background: rgba(220, 38, 38, 0.05);
        }

        .problem-card.high {
            border-color: #ea580c;
            background: rgba(234, 88, 12, 0.05);
        }

        .problem-card.medium {
            border-color: #d97706;
            background: rgba(217, 119, 6, 0.05);
        }

        .problem-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .problem-title {
            font-weight: 600;
            font-size: 1.05rem;
        }

        .problem-confidence {
            background: rgba(0,0,0,0.1);
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .problem-description {
            color: var(--text2);
            font-size: 0.9rem;
            margin-bottom: 8px;
        }

        .affected-components {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }

        .component-tag {
            background: var(--primary);
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.75rem;
        }

        .root-cause-panel {
            background: var(--bg2);
            border-radius: 8px;
            padding: 20px;
            margin-top: 20px;
        }

        .likely-causes {
            margin-bottom: 20px;
        }

        .cause-item {
            background: var(--bg);
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 8px;
            border-left: 3px solid var(--primary);
        }

        .cause-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
        }

        .cause-title {
            font-weight: 600;
        }

        .cause-confidence {
            font-size: 0.8rem;
            color: var(--text2);
        }

        .debugging-steps {
            background: var(--bg);
            padding: 16px;
            border-radius: 6px;
            margin-bottom: 16px;
        }

        .debugging-steps h5 {
            margin: 0 0 12px 0;
            color: var(--primary);
        }

        .debugging-steps ol {
            margin: 0;
            padding-left: 20px;
        }

        .debugging-steps li {
            margin-bottom: 6px;
            font-size: 0.9rem;
        }

        .recommendations {
            display: grid;
            gap: 12px;
        }

        .recommendation-item {
            background: var(--bg);
            padding: 12px;
            border-radius: 6px;
            border-left: 3px solid var(--success);
        }

        .rec-header {
            display: flex;
            justify-content: between;
            align-items: center;
            margin-bottom: 6px;
        }

        .rec-priority {
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--primary);
        }

        .rec-effort {
            font-size: 0.75rem;
            color: var(--text2);
            margin-left: auto;
        }

        .problem-alert {
            animation: slideInFromRight 0.3s ease;
        }

        @keyframes slideInFromRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        /* 🕵️ Root Cause Analysis Panel Styles */
        .root-cause-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        .root-cause-panel {
            background: white;
            border-radius: 15px;
            max-width: 90vw;
            max-height: 90vh;
            overflow: auto;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        .panel-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 15px 15px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .close-panel {
            background: none;
            border: none;
            color: white;
            font-size: 28px;
            cursor: pointer;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.3s;
        }

        .close-panel:hover {
            background: rgba(255,255,255,0.2);
        }

        .panel-content {
            padding: 30px;
        }

        .problem-summary {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 25px;
            border-left: 5px solid #dc3545;
        }

        .problem-header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 10px;
        }

        .severity-badge {
            padding: 4px 12px;
            border-radius: 15px;
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
        }

        .severity-badge.high {
            background: #dc3545;
            color: white;
        }

        .severity-badge.medium {
            background: #ffc107;
            color: #212529;
        }

        .severity-badge.low {
            background: #28a745;
            color: white;
        }

        .problem-description {
            color: #6c757d;
            margin: 10px 0;
        }

        .affected-threads {
            color: #495057;
            font-size: 14px;
        }

        .analysis-sections {
            display: grid;
            gap: 25px;
        }

        .analysis-section {
            background: white;
            border-radius: 10px;
            padding: 20px;
            border: 1px solid #e9ecef;
        }

        .analysis-section h4 {
            color: #495057;
            margin-bottom: 15px;
            font-size: 18px;
        }

        .causes-list {
            display: grid;
            gap: 15px;
        }

        .cause-item {
            border-radius: 8px;
            padding: 15px;
            border-left: 4px solid;
        }

        .cause-item.primary {
            background: #fff5f5;
            border-color: #dc3545;
        }

        .cause-item.secondary {
            background: #fff8e1;
            border-color: #ffc107;
        }

        .cause-item.tertiary {
            background: #f3f4f6;
            border-color: #6c757d;
        }

        .cause-header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 10px;
        }

        .confidence-bar {
            width: 100px;
            height: 8px;
            background: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
        }

        .confidence-fill {
            height: 100%;
            background: linear-gradient(90deg, #28a745, #ffc107, #dc3545);
            transition: width 0.5s ease;
        }

        .confidence-text {
            font-weight: bold;
            color: #495057;
            min-width: 40px;
        }

        .cause-evidence {
            color: #6c757d;
            font-size: 14px;
        }

        .evidence-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        .evidence-card {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            border: 1px solid #dee2e6;
        }

        .evidence-card h5 {
            color: #495057;
            margin-bottom: 15px;
        }

        .mini-flame-graph {
            margin: 15px 0;
        }

        .flame-bar {
            height: 25px;
            margin: 2px 0;
            border-radius: 3px;
            display: flex;
            align-items: center;
            padding: 0 10px;
            color: white;
            font-size: 12px;
            font-weight: bold;
        }

        .mini-ffi-audit {
            margin: 15px 0;
        }

        .ffi-boundary {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: white;
            border-radius: 5px;
            margin: 5px 0;
            border: 1px solid #dee2e6;
        }

        .boundary-label {
            font-weight: bold;
            color: #495057;
        }

        .resource-count {
            color: #6c757d;
            font-size: 12px;
        }

        .leak-indicator {
            font-size: 16px;
        }

        .mini-thread-map {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin: 15px 0;
        }

        .thread-node {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            background: #6c757d;
        }

        .thread-node.active {
            background: #28a745;
        }

        .thread-node.contention {
            background: #dc3545;
            animation: pulse 1s infinite;
        }

        .thread-connection {
            width: 30px;
            height: 2px;
            background: #dee2e6;
        }

        .expand-evidence {
            background: #007bff;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.3s;
        }

        .expand-evidence:hover {
            background: #0056b3;
        }

        .debugging-checklist {
            display: grid;
            gap: 12px;
        }

        .debug-step {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #dee2e6;
        }

        .debug-checkbox {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .debug-label {
            cursor: pointer;
            flex: 1;
            transition: all 0.3s;
        }

        .recommendations-list {
            display: grid;
            gap: 15px;
        }

        .recommendation-item {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #dee2e6;
        }

        .rec-icon {
            font-size: 20px;
        }

        .rec-text {
            flex: 1;
            color: #495057;
        }

        .apply-rec-btn {
            background: #28a745;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.3s;
        }

        .apply-rec-btn:hover {
            background: #1e7e34;
        }

        .investigate-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.3s;
            margin-top: 10px;
        }

        .investigate-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        /* Health Assessment Panel Styles */
        .health-assessment {
            background: linear-gradient(135deg, var(--card-bg) 0%, rgba(72, 187, 120, 0.1) 100%);
            border: 2px solid rgba(72, 187, 120, 0.3);
            border-radius: 12px;
            padding: 1.5rem;
            margin: 1rem 0;
        }

        .health-summary {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 2rem;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .health-score {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .score-circle {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: conic-gradient(var(--success) 0deg 306deg, var(--card-bg) 306deg 360deg);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            position: relative;
            font-weight: bold;
        }

        .score-circle::before {
            content: '';
            position: absolute;
            width: 60px;
            height: 60px;
            background: var(--card-bg);
            border-radius: 50%;
            z-index: -1;
        }

        #health-score-value {
            font-size: 1.5rem;
            color: var(--success);
        }

        .score-unit {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        .health-status {
            text-align: center;
        }

        .status-text {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
        }

        .health-emoji {
            font-size: 1.5rem;
        }

        .vital-signs {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
        }

        .vital-sign {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .vital-icon {
            font-size: 1.2rem;
        }

        .vital-label {
            flex: 1;
            font-weight: 500;
        }

        .vital-value {
            font-weight: 600;
            color: var(--accent);
        }

        .health-recommendations {
            background: rgba(72, 187, 120, 0.1);
            border-radius: 8px;
            padding: 1rem;
            border-left: 4px solid var(--success);
        }

        .health-recommendations h5 {
            margin: 0 0 0.5rem 0;
            color: var(--success);
        }

        .health-recommendations ul {
            margin: 0;
            padding-left: 1.5rem;
        }

        .health-recommendations li {
            margin-bottom: 0.25rem;
            color: var(--text-secondary);
        }

        /* Health score color variations */
        .health-critical { --health-color: var(--danger); }
        .health-warning { --health-color: var(--warning); }
        .health-good { --health-color: var(--success); }
        .health-excellent { --health-color: #00d084; }

        /* Memory Stories Panel Styles */
        .memory-stories {
            background: linear-gradient(135deg, var(--card-bg) 0%, rgba(138, 43, 226, 0.1) 100%);
            border: 2px solid rgba(138, 43, 226, 0.3);
            border-radius: 12px;
            padding: 1.5rem;
            margin: 1rem 0;
        }

        .story-summary {
            margin-bottom: 1.5rem;
        }

        .story-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 1rem;
        }

        .story-title {
            font-size: 1.3rem;
            font-weight: 700;
            color: #8a2be2;
            font-family: 'Georgia', serif;
        }

        .story-genre {
            background: rgba(138, 43, 226, 0.2);
            color: #8a2be2;
            padding: 0.25rem 0.75rem;
            border-radius: 15px;
            font-size: 0.9rem;
            font-weight: 600;
        }

        .character-gallery h5 {
            margin: 0 0 0.75rem 0;
            color: #8a2be2;
        }

        .characters-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 0.75rem;
        }

        .character-card {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(138, 43, 226, 0.3);
            border-radius: 8px;
            padding: 0.75rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .character-card:hover {
            background: rgba(138, 43, 226, 0.2);
            transform: translateY(-2px);
        }

        .character-emoji {
            font-size: 1.5rem;
            display: block;
            margin-bottom: 0.25rem;
        }

        .character-name {
            font-weight: 600;
            color: var(--text);
            font-size: 0.9rem;
        }

        .character-role {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-top: 0.25rem;
        }

        .story-chapters {
            margin-bottom: 1.5rem;
        }

        .chapter-tabs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }

        .chapter-tab {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(138, 43, 226, 0.3);
            border-radius: 8px;
            padding: 0.5rem 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            color: var(--text);
            font-weight: 500;
        }

        .chapter-tab.active {
            background: rgba(138, 43, 226, 0.3);
            border-color: #8a2be2;
            color: #8a2be2;
        }

        .chapter-tab:hover {
            background: rgba(138, 43, 226, 0.2);
        }

        .chapter-content {
            position: relative;
            min-height: 150px;
        }

        .chapter {
            display: none;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 1.25rem;
            border-left: 4px solid #8a2be2;
        }

        .chapter.active {
            display: block;
            animation: fadeIn 0.3s ease;
        }

        .story-text {
            font-size: 1rem;
            line-height: 1.6;
            color: var(--text);
            font-family: 'Georgia', serif;
            margin-bottom: 1rem;
        }

        .character-mention {
            color: #8a2be2;
            font-weight: 600;
            background: rgba(138, 43, 226, 0.1);
            padding: 0.1rem 0.3rem;
            border-radius: 3px;
        }

        .highlight {
            background: linear-gradient(120deg, rgba(138, 43, 226, 0.3) 0%, rgba(138, 43, 226, 0.1) 100%);
            color: #8a2be2;
            font-weight: 600;
            padding: 0.1rem 0.3rem;
            border-radius: 3px;
        }

        .lessons-learned {
            background: rgba(138, 43, 226, 0.1);
            border-radius: 8px;
            padding: 1rem;
            margin-top: 1rem;
        }

        .lessons-learned h6 {
            margin: 0 0 0.5rem 0;
            color: #8a2be2;
            font-weight: 600;
        }

        .lessons-learned ul {
            margin: 0;
            padding-left: 1.5rem;
        }

        .lessons-learned li {
            margin-bottom: 0.25rem;
            color: var(--text-secondary);
        }

        .story-actions {
            display: flex;
            gap: 1rem;
            justify-content: center;
        }

        .story-btn {
            background: rgba(138, 43, 226, 0.2);
            border: 1px solid #8a2be2;
            color: #8a2be2;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .story-btn:hover {
            background: #8a2be2;
            color: white;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Help button and modal styles */
        .help-btn {
            background: rgba(72, 187, 120, 0.2);
            border: 1px solid var(--success);
            color: var(--success);
            border-radius: 50%;
            width: 24px;
            height: 24px;
            font-size: 12px;
            cursor: pointer;
            margin-left: 0.5rem;
            transition: all 0.3s ease;
        }

        .help-btn:hover {
            background: var(--success);
            color: white;
            transform: scale(1.1);
        }

        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background: var(--card-bg);
            border: 2px solid var(--success);
            border-radius: 12px;
            padding: 2rem;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            border-bottom: 1px solid var(--border);
            padding-bottom: 1rem;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--text-secondary);
        }

        .modal-close:hover {
            color: var(--danger);
        }

        .scoring-table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            overflow: hidden;
        }

        .scoring-table th,
        .scoring-table td {
            padding: 0.75rem;
            text-align: left;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .scoring-table th {
            background: rgba(72, 187, 120, 0.2);
            color: var(--success);
            font-weight: 600;
        }

        .scoring-table tr:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .score-excellent { color: #00d084; }
        .score-good { color: #f6e05e; }
        .score-fair { color: #ed8936; }
        .score-poor { color: #e53e3e; }
        .score-critical { color: #c53030; }

        /* Memory Landscape - 简单直观的内存可视化 */
        .memory-landscape {
            background: linear-gradient(135deg, var(--card-bg) 0%, rgba(34, 139, 34, 0.1) 100%);
            border: 2px solid rgba(34, 139, 34, 0.3);
            border-radius: 12px;
            padding: 1.5rem;
            margin: 1rem 0;
        }

        .landscape-controls {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }

        .landscape-btn {
            background: rgba(34, 139, 34, 0.2);
            border: 1px solid #228B22;
            color: #228B22;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .landscape-btn.active {
            background: #228B22;
            color: white;
            box-shadow: 0 0 15px rgba(34, 139, 34, 0.5);
        }

        .landscape-btn:hover {
            background: #228B22;
            color: white;
            transform: translateY(-2px);
        }

        .landscape-description {
            background: rgba(34, 139, 34, 0.1);
            border-radius: 8px;
            padding: 0.75rem;
            margin-bottom: 1rem;
            border-left: 4px solid #228B22;
        }

        .landscape-description p {
            margin: 0;
            color: var(--text);
            font-size: 0.9rem;
        }

        .memory-landscape-container {
            min-height: 400px;
            background: linear-gradient(180deg, #87CEEB 0%, #32CD32 70%, #228B22 100%);
            border-radius: 12px;
            padding: 2rem;
            position: relative;
            overflow: hidden;
            perspective: 1000px;
        }

        /* Building styles */
        .memory-building {
            position: absolute;
            bottom: 0;
            border-radius: 4px 4px 0 0;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: flex-end;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 0.8rem;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
        }

        .memory-building:hover {
            transform: scale(1.1) translateY(-10px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
            z-index: 10;
        }

        .memory-building.healthy {
            background: linear-gradient(180deg, #90EE90, #32CD32);
        }

        .memory-building.moderate {
            background: linear-gradient(180deg, #FFD700, #FFA500);
        }

        .memory-building.high {
            background: linear-gradient(180deg, #FF8C00, #FF6347);
        }

        .memory-building.critical {
            background: linear-gradient(180deg, #FF4500, #DC143C);
        }

        /* Street labels */
        .street-label {
            position: absolute;
            bottom: -30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.8rem;
            white-space: nowrap;
        }

        /* Heatmap mode */
        .heatmap-cell {
            position: absolute;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 0.7rem;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
        }

        .heatmap-cell:hover {
            transform: scale(1.2);
            z-index: 10;
        }

        /* Bar chart mode */
        .bar-chart-container {
            display: flex;
            align-items: flex-end;
            justify-content: space-around;
            height: 100%;
            padding: 2rem 1rem;
        }

        .memory-bar {
            background: linear-gradient(180deg, #32CD32, #228B22);
            border-radius: 8px 8px 0 0;
            position: relative;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: flex-end;
            justify-content: center;
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
        }

        .memory-bar:hover {
            transform: scale(1.05);
            filter: brightness(1.2);
        }

        .landscape-legend {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 1rem;
            margin-top: 1rem;
            border: 1px solid rgba(34, 139, 34, 0.3);
        }

        .landscape-legend h5 {
            margin: 0 0 0.75rem 0;
            color: #228B22;
            font-weight: 600;
        }

        .landscape-legend .legend-items {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 0.5rem;
        }

        .landscape-legend .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .landscape-legend .legend-color {
            width: 20px;
            height: 16px;
            border-radius: 3px;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .landscape-legend .legend-color.healthy {
            background: linear-gradient(180deg, #90EE90, #32CD32);
        }

        .landscape-legend .legend-color.moderate {
            background: linear-gradient(180deg, #FFD700, #FFA500);
        }

        .landscape-legend .legend-color.high {
            background: linear-gradient(180deg, #FF8C00, #FF6347);
        }

        .landscape-legend .legend-color.critical {
            background: linear-gradient(180deg, #FF4500, #DC143C);
        }

        .variable-detail-panel {
            background: rgba(34, 139, 34, 0.1);
            border: 1px solid #228B22;
            border-radius: 8px;
            padding: 1rem;
            margin-top: 1rem;
            max-height: 200px;
            overflow-y: auto;
        }

        .variable-detail-panel h5 {
            margin: 0 0 0.75rem 0;
            color: #228B22;
            font-weight: 600;
        }

        #detail-content {
            color: var(--text-secondary);
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 0.9rem;
            line-height: 1.4;
        }

        .detail-item {
            margin-bottom: 0.5rem;
            padding: 0.25rem 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .detail-item:last-child {
            border-bottom: none;
        }

        .detail-label {
            color: #228B22;
            font-weight: 600;
        }

        .detail-value {
            color: var(--text);
        }

        .building-grow {
            animation: buildingGrow 2s ease-out;
        }

        @keyframes buildingGrow {
            from {
                height: 0;
                opacity: 0;
            }
            to {
                height: var(--final-height);
                opacity: 1;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>{{TITLE}}</h1>
            <div class="controls">
                <button class="btn" id="theme-toggle" onclick="window.toggleTheme()">🌙 Dark Mode</button>
                <button class="btn" id="memory-map-toggle" onclick="window.toggleMemoryMap()">🗺️ Thread Memory</button>
            </div>
        </div>

        <div class="stats-grid">
            <div class="stat-card" onclick="window.focusAttribution('memory')">
                <div class="stat-value" style="color: var(--primary);">{{TOTAL_MEMORY}}</div>
                <div class="stat-label">Total Memory</div>
            </div>
            <div class="stat-card" onclick="window.focusAttribution('variables')">
                <div class="stat-value" style="color: var(--success);">{{TOTAL_VARIABLES}}</div>
                <div class="stat-label">Total Variables</div>
            </div>
            <div class="stat-card" onclick="window.focusAttribution('threads')">
                <div class="stat-value" style="color: var(--warning);">{{THREAD_COUNT}}</div>
                <div class="stat-label">Active Threads</div>
            </div>
            <div class="stat-card" onclick="window.focusAttribution('efficiency')">
                <div class="stat-value" style="color: var(--accent);">{{EFFICIENCY}}%</div>
                <div class="stat-label">Memory Efficiency</div>
            </div>
        </div>

        <!-- Memory Health Assessment Panel -->
        <div class="section health-assessment">
            <h3>
                🩺 Memory Health Assessment
                <button class="help-btn" onclick="showHealthScoringGuide()" title="查看评分标准">
                    ❓
                </button>
            </h3>
            <div class="health-summary">
                <div class="health-score">
                    <div class="score-circle" id="health-score-circle">
                        <span id="health-score-value">85</span>
                        <span class="score-unit">/100</span>
                    </div>
                    <div class="health-status">
                        <div class="status-text" id="health-status">Good Health</div>
                        <div class="health-emoji" id="health-emoji">💛🩺</div>
                    </div>
                </div>
                <div class="vital-signs">
                    <div class="vital-sign">
                        <span class="vital-icon">🩸</span>
                        <span class="vital-label">Memory Pressure</span>
                        <span class="vital-value" id="memory-pressure">Normal</span>
                    </div>
                    <div class="vital-sign">
                        <span class="vital-icon">🫁</span>
                        <span class="vital-label">Thread Efficiency</span>
                        <span class="vital-value" id="thread-efficiency">85%</span>
                    </div>
                    <div class="vital-sign">
                        <span class="vital-icon">❤️</span>
                        <span class="vital-label">Allocation Rate</span>
                        <span class="vital-value" id="allocation-rate">Normal</span>
                    </div>
                    <div class="vital-sign">
                        <span class="vital-icon">🌡️</span>
                        <span class="vital-label">Fragmentation</span>
                        <span class="vital-value" id="fragmentation-level">Low</span>
                    </div>
                </div>
            </div>
            <div class="health-recommendations" id="health-recommendations">
                <h5>💊 Health Recommendations</h5>
                <ul id="recommendations-list">
                    <li>✅ Memory usage is healthy - maintain current practices</li>
                </ul>
            </div>
        </div>

        <div class="section">
            <h3>🧵 Thread Variables</h3>
            
            <div class="variables-controls">
                <div class="variable-legend">
                    <h5>Performance Categories:</h5>
                    <div class="legend-items">
                        <div class="legend-item" onclick="filterByCategory('cpu')">
                            <div class="legend-color cpu-intensive"></div>
                            <span>CPU Intensive</span>
                        </div>
                        <div class="legend-item" onclick="filterByCategory('io')">
                            <div class="legend-color io-intensive"></div>
                            <span>I/O Heavy</span>
                        </div>
                        <div class="legend-item" onclick="filterByCategory('memory')">
                            <div class="legend-color memory-intensive"></div>
                            <span>Memory Heavy</span>
                        </div>
                        <div class="legend-item" onclick="filterByCategory('async')">
                            <div class="legend-color async-heavy"></div>
                            <span>Async Heavy</span>
                        </div>
                        <div class="legend-item" onclick="filterByCategory('normal')">
                            <div class="legend-color normal"></div>
                            <span>Normal</span>
                        </div>
                        <div class="legend-item" onclick="filterByCategory('all')">
                            <div class="legend-color all"></div>
                            <span>Show All</span>
                        </div>
                    </div>
                </div>
                
                <div class="variable-filters">
                    <div class="filter-group">
                        <label>Sort by:</label>
                        <select id="sort-select" onchange="sortVariables(this.value)">
                            <option value="memory">Memory Usage</option>
                            <option value="allocations">Allocation Count</option>
                            <option value="performance">Performance Impact</option>
                            <option value="thread">Thread ID</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label>Thread:</label>
                        <select id="thread-filter" onchange="filterByThread(this.value)">
                            <option value="all">All Threads</option>
                            <option value="1">Thread 1</option>
                            <option value="2">Thread 2</option>
                            <option value="3">Thread 3</option>
                            <option value="4">Thread 4</option>
                            <option value="5">Thread 5+</option>
                        </select>
                    </div>
                </div>
            </div>
            
            <div class="variables-grid" id="variables-container">
                {{VARIABLES_HTML}}
            </div>
        </div>

        <div class="section memory-layout-section" style="display: none;">
            <h3>🗺️ Thread Memory Distribution</h3>
            <div class="layout-description">
                <p>🎯 <strong>Shows:</strong> How much memory each thread is using - like a mini bar chart</p>
                <p>🔍 <strong>Use case:</strong> Spot if one thread is hogging all the memory (memory imbalance)</p>
                <p>💡 <strong>Think:</strong> "Which thread is the memory hog?"</p>
            </div>
            <div id="memory-map-content">
                {{MEMORY_MAP_HTML}}
            </div>
        </div>

        <div class="section diagnostics-section">
            <h3>🔍 Code Problem Locator</h3>
            <div class="diagnostics-description">
                <p>🎯 <strong>Pinpoint code issues:</strong> Like a flame graph, but for memory problems - find the exact variable/thread causing issues</p>
                <p>⚡ <strong>Instant analysis:</strong> One-click scanning to identify problem sources in your codebase</p>
            </div>
            <div class="diagnostics-controls">
                <button class="btn" onclick="triggerManualScan()">
                    🔎 Scan for Problems
                </button>
                <button class="btn btn-secondary" onclick="generatePerformanceReport()">
                    📊 Performance Report
                </button>
            </div>
            <div id="active-problems" class="active-problems">
                <div class="no-problems">
                    <div class="status-indicator">
                        <div class="status-icon">🎯</div>
                        <div class="status-text">
                            <h4>Ready for Code Analysis</h4>
                            <p>Click "Scan for Problems" to analyze your current memory usage patterns</p>
                            <small>Tracking {{TOTAL_VARIABLES}} variables across {{THREAD_COUNT}} threads</small>
                        </div>
                    </div>
                    <div class="quick-insights">
                        <div class="insight-card">
                            <span class="insight-icon">🧠</span>
                            <div>
                                <strong>Memory Efficiency</strong>
                                <p>85.2% - Above average</p>
                            </div>
                        </div>
                        <div class="insight-card">
                            <span class="insight-icon">⚡</span>
                            <div>
                                <strong>Thread Performance</strong>
                                <p>Optimal load distribution</p>
                            </div>
                        </div>
                        <div class="insight-card">
                            <span class="insight-icon">🔄</span>
                            <div>
                                <strong>Async Health</strong>
                                <p>No blocked futures detected</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div id="root-cause-analysis" class="root-cause-panel" style="display: none;">
                <!-- Root cause analysis will be populated here -->
            </div>
        </div>
    </div>

    <!-- Modal for variable details -->
    <div id="variable-modal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal()">&times;</span>
            <div id="modal-body"></div>
        </div>
    </div>


    <!-- Include JavaScript -->
    <script src="hybrid_dashboard.js"></script>
    <script src="enhanced_diagnostics.js"></script>
    <script>
        // Initialize with data
        window.DASHBOARD_DATA = {
            variables: {{VARIABLES_DATA}},
            threads: {{THREADS_DATA}},
            tasks: {{TASKS_DATA}}
        };
        
        console.log('🎯 Attribution Analysis Dashboard initialized');
        console.log('🔍 Ready for 3-click root cause discovery');
        
        // Memory Health Analysis - Simple and effective!
        window.calculateMemoryHealth = function() {
            const totalMemory = parseInt('{{TOTAL_MEMORY}}'.replace(/[^\d]/g, '')) || 0;
            const totalVariables = parseInt('{{TOTAL_VARIABLES}}') || 0;
            const threadCount = parseInt('{{THREAD_COUNT}}') || 1;
            const efficiency = parseFloat('{{EFFICIENCY}}') || 100;
            
            // Calculate vital signs
            const avgMemoryPerVar = totalVariables > 0 ? totalMemory / totalVariables : 0;
            const varsPerThread = totalVariables / threadCount;
            
            // Memory pressure assessment
            let memoryPressure = "Normal";
            if (avgMemoryPerVar > 102400) memoryPressure = "Critical"; // >100KB per var
            else if (avgMemoryPerVar > 10240) memoryPressure = "High"; // >10KB per var  
            else if (avgMemoryPerVar > 1024) memoryPressure = "Elevated"; // >1KB per var
            
            // Thread efficiency
            const threadEfficiency = varsPerThread <= 10 ? 100 : 
                                   varsPerThread <= 30 ? 85 :
                                   varsPerThread <= 100 ? 70 : 50;
            
            // Allocation rate
            let allocationRate = "Normal";
            if (totalVariables > 1000) allocationRate = "Excessive";
            else if (totalVariables > 500) allocationRate = "High";
            else if (totalVariables < 100) allocationRate = "Low";
            
            // Fragmentation (simplified)
            const fragmentation = efficiency > 90 ? "Minimal" :
                                efficiency > 80 ? "Low" :
                                efficiency > 60 ? "Moderate" : "High";
            
            // Calculate overall health score
            let healthScore = 100;
            if (memoryPressure === "Critical") healthScore -= 40;
            else if (memoryPressure === "High") healthScore -= 25;
            else if (memoryPressure === "Elevated") healthScore -= 10;
            
            healthScore -= Math.max(0, (100 - threadEfficiency) * 0.3);
            
            if (allocationRate === "Excessive") healthScore -= 25;
            else if (allocationRate === "High") healthScore -= 10;
            
            if (fragmentation === "High") healthScore -= 20;
            else if (fragmentation === "Moderate") healthScore -= 10;
            
            healthScore = Math.max(0, Math.round(healthScore));
            
            // Health status and emoji
            let healthStatus, healthEmoji, healthColor;
            if (healthScore >= 90) {
                healthStatus = "Excellent Health";
                healthEmoji = "💚🩺";
                healthColor = "#00d084";
            } else if (healthScore >= 75) {
                healthStatus = "Good Health";
                healthEmoji = "💛🩺";
                healthColor = "#f6e05e";
            } else if (healthScore >= 60) {
                healthStatus = "Fair Health - Needs Attention";
                healthEmoji = "🧡🩺";
                healthColor = "#ed8936";
            } else if (healthScore >= 40) {
                healthStatus = "Poor Health - Action Required";
                healthEmoji = "❤️🩺";
                healthColor = "#e53e3e";
            } else {
                healthStatus = "Critical - Immediate Action Needed";
                healthEmoji = "🆘🚨";
                healthColor = "#c53030";
            }
            
            // Generate recommendations
            const recommendations = [];
            if (memoryPressure === "High" || memoryPressure === "Critical") {
                recommendations.push("💊 Use Vec::with_capacity() to pre-allocate memory");
                recommendations.push("🔄 Implement object pooling for frequently allocated types");
            }
            if (threadEfficiency < 70) {
                recommendations.push("🧵 Optimize thread-to-variable ratio (target: 10-30 vars per thread)");
                recommendations.push("📊 Use Arc<T> for shared data instead of cloning");
            }
            if (allocationRate === "Excessive") {
                recommendations.push("⚡ Reduce allocation frequency with buffering strategies");
            }
            if (fragmentation === "High") {
                recommendations.push("🧹 Implement memory defragmentation strategies");
            }
            if (healthScore >= 85) {
                recommendations.push("✅ Memory usage is healthy - maintain current practices");
            }
            
            return {
                score: healthScore,
                status: healthStatus,
                emoji: healthEmoji,
                color: healthColor,
                memoryPressure,
                threadEfficiency: threadEfficiency.toFixed(0) + "%",
                allocationRate,
                fragmentation,
                recommendations
            };
        };
        
        // Update health display
        window.updateHealthDisplay = function() {
            const health = window.calculateMemoryHealth();
            
            // Update score circle
            const scoreCircle = document.getElementById('health-score-circle');
            const scoreValue = document.getElementById('health-score-value');
            const percentage = (health.score / 100) * 360;
            
            scoreCircle.style.background = `conic-gradient(${health.color} 0deg ${percentage}deg, var(--card-bg) ${percentage}deg 360deg)`;
            scoreValue.textContent = health.score;
            scoreValue.style.color = health.color;
            
            // Update status
            document.getElementById('health-status').textContent = health.status;
            document.getElementById('health-emoji').textContent = health.emoji;
            
            // Update vital signs
            document.getElementById('memory-pressure').textContent = health.memoryPressure;
            document.getElementById('thread-efficiency').textContent = health.threadEfficiency;
            document.getElementById('allocation-rate').textContent = health.allocationRate;
            document.getElementById('fragmentation-level').textContent = health.fragmentation;
            
            // Update recommendations
            const recommendationsList = document.getElementById('recommendations-list');
            recommendationsList.innerHTML = health.recommendations.map(rec => `<li>${rec}</li>`).join('');
            
            console.log('🩺 Health assessment updated:', health);
        };
        
        // Initialize health display
        window.updateHealthDisplay();
        
        // Memory Story Generation System - Transform data into narratives!
        window.memoryStoryGenerator = {
            // Character archetypes based on thread behavior
            characterTypes: {
                hoarder: { emoji: "🐿️", name: "The Hoarder", trait: "allocates but rarely deallocates" },
                optimizer: { emoji: "⚡", name: "The Optimizer", trait: "efficient memory patterns" },
                sprinter: { emoji: "🏃", name: "The Sprinter", trait: "fast allocation/deallocation" },
                worker: { emoji: "🔧", name: "The Worker", trait: "steady, consistent patterns" },
                leak: { emoji: "👻", name: "The Memory Leak", trait: "never cleans up" }
            },
            
            // Story templates for different scenarios
            storyTemplates: {
                optimization: {
                    genre: "Success Story",
                    setup: "In the bustling city of Thread Town, {threadCount} dedicated workers began their daily tasks.",
                    action: "The workers discovered they could work more efficiently by pre-allocating their memory spaces.",
                    climax: "At peak performance, they managed {totalMemory} of memory with {efficiency}% efficiency!",
                    resolution: "Through teamwork and smart planning, they achieved optimal memory harmony."
                },
                competition: {
                    genre: "Adventure",
                    setup: "A great competition arose in Memory Valley between {threadCount} ambitious threads.",
                    action: "Each thread fought valiantly to claim their share of the {totalMemory} treasure.",
                    climax: "The battle reached its peak when all threads simultaneously demanded memory!",
                    resolution: "Peace was restored when they learned to share resources using Arc<T> and proper coordination."
                },
                mystery: {
                    genre: "Mystery",
                    setup: "Detective Thread noticed something strange - memory was disappearing without a trace...",
                    action: "The investigation revealed {totalVariables} suspects, each with their own memory alibis.",
                    climax: "The mystery deepened when {totalMemory} of memory couldn't be accounted for!",
                    resolution: "The case was solved when they implemented proper deallocation tracking."
                },
                educational: {
                    genre: "Fable",
                    setup: "Once upon a time, there was a young thread who learned about memory management...",
                    action: "The thread made many mistakes, creating {totalVariables} variables without thinking.",
                    climax: "Soon, the thread ran out of memory space and couldn't create any more variables!",
                    resolution: "The wise Optimizer taught the thread about Vec::with_capacity() and object pooling."
                }
            },
            
            // Analyze data to determine story type and characters
            analyzeMemoryStory: function() {
                const totalMemory = parseInt('{{TOTAL_MEMORY}}'.replace(/[^\d]/g, '')) || 0;
                const totalVariables = parseInt('{{TOTAL_VARIABLES}}') || 0;
                const threadCount = parseInt('{{THREAD_COUNT}}') || 1;
                const efficiency = parseFloat('{{EFFICIENCY}}') || 100;
                
                // Determine story type based on data patterns
                let storyType = 'educational'; // default
                if (efficiency > 85) storyType = 'optimization';
                else if (threadCount > 10) storyType = 'competition';
                else if (totalVariables > 1000) storyType = 'mystery';
                
                // Generate characters based on thread behavior
                const characters = this.generateCharacters(threadCount, totalVariables, efficiency);
                
                return {
                    type: storyType,
                    characters: characters,
                    data: { totalMemory: '{{TOTAL_MEMORY}}', totalVariables, threadCount, efficiency }
                };
            },
            
            // Generate character lineup based on patterns
            generateCharacters: function(threadCount, totalVariables, efficiency) {
                const characters = [];
                const varsPerThread = totalVariables / threadCount;
                
                // Assign character types based on behavior patterns
                for (let i = 0; i < Math.min(threadCount, 6); i++) {
                    let characterType;
                    
                    if (efficiency > 90) characterType = 'optimizer';
                    else if (varsPerThread > 100) characterType = 'hoarder';
                    else if (threadCount > 15) characterType = 'sprinter';
                    else if (i === threadCount - 1 && efficiency < 60) characterType = 'leak';
                    else characterType = 'worker';
                    
                    const template = this.characterTypes[characterType];
                    characters.push({
                        id: `thread-${i}`,
                        emoji: template.emoji,
                        name: `${template.name} ${i + 1}`,
                        role: template.trait,
                        type: characterType
                    });
                }
                
                return characters;
            },
            
            // Generate full story from template
            generateStory: function(analysis) {
                const template = this.storyTemplates[analysis.type];
                const data = analysis.data;
                
                return {
                    title: this.generateTitle(analysis.type, data),
                    genre: template.genre,
                    chapters: {
                        setup: this.fillTemplate(template.setup, data),
                        action: this.fillTemplate(template.action, data),
                        climax: this.fillTemplate(template.climax, data),
                        resolution: this.fillTemplate(template.resolution, data)
                    },
                    lessons: this.generateLessons(analysis)
                };
            },
            
            // Generate dynamic titles
            generateTitle: function(type, data) {
                const titles = {
                    optimization: `The Optimization Heroes of Thread City`,
                    competition: `The Great Memory War of ${data.threadCount} Threads`,
                    mystery: `The Case of the Missing ${data.totalMemory}`,
                    educational: `The Thread Who Learned to Manage Memory`
                };
                return titles[type] || "A Memory Tale";
            },
            
            // Fill template with actual data
            fillTemplate: function(template, data) {
                return template
                    .replace(/{threadCount}/g, data.threadCount)
                    .replace(/{totalMemory}/g, data.totalMemory)
                    .replace(/{totalVariables}/g, data.totalVariables)
                    .replace(/{efficiency}/g, data.efficiency);
            },
            
            // Generate educational lessons
            generateLessons: function(analysis) {
                const lessons = [];
                const { efficiency, totalVariables, threadCount } = analysis.data;
                
                if (efficiency > 85) {
                    lessons.push("Excellent memory efficiency leads to better performance");
                }
                if (totalVariables / threadCount > 50) {
                    lessons.push("Consider using object pooling for frequently allocated objects");
                    lessons.push("Vec::with_capacity() can reduce allocation overhead");
                }
                if (threadCount > 10) {
                    lessons.push("Thread coordination becomes crucial with many concurrent workers");
                    lessons.push("Arc<T> and Rc<T> help share data efficiently between threads");
                }
                if (efficiency < 70) {
                    lessons.push("Memory fragmentation may be impacting performance");
                    lessons.push("Regular memory profiling helps identify optimization opportunities");
                }
                
                return lessons.length > 0 ? lessons : ["Memory management is a continuous learning journey"];
            }
        };
        
        // Story UI management functions
        window.showChapter = function(chapterName, event) {
            // Update tabs
            document.querySelectorAll('.chapter-tab').forEach(tab => tab.classList.remove('active'));
            event.target.classList.add('active');
            
            // Update content
            document.querySelectorAll('.chapter').forEach(chapter => chapter.classList.remove('active'));
            document.getElementById(chapterName + '-content').classList.add('active');
        };

        
        // Health Scoring Guide Modal Functions
        window.showHealthScoringGuide = function() {
            const modal = document.getElementById('scoring-guide-modal');
            modal.style.display = 'flex';
            document.body.style.overflow = 'hidden'; // Prevent background scrolling
        };
        
        window.closeModal = function() {
            // Close all visible modals
            const modals = document.querySelectorAll('.modal');
            modals.forEach(modal => {
                if (modal && modal.style.display !== 'none') {
                    modal.style.display = 'none';
                }
            });
            document.body.style.overflow = 'auto'; // Restore scrolling
        };
        
        // Close modal when clicking outside (for all modals)
        const allModals = document.querySelectorAll('.modal');
        allModals.forEach(modal => {
            if (modal) {
                modal.addEventListener('click', function(e) {
                    if (e.target === this) {
                        window.closeModal();
                    }
                });
            }
        });
        
        // Close modal with Escape key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                window.closeModal();
            }
        });
        
        // Landscape control functions
        window.switchLandscapeView = function(viewType) {
            // Update button states
            document.querySelectorAll('.landscape-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(viewType + '-btn').classList.add('active');
            
            // Update description
            const descriptions = {
                cityscape: "🏙️ <strong>Memory City:</strong> Each thread is a street, variables are buildings. Building height = memory size, color = health status.",
                heatmap: "🌡️ <strong>Heat Map:</strong> Grid showing all variables, color represents memory usage health status, uniform size for easy comparison.",
                timeline: "📊 <strong>Bar Chart:</strong> Summary by thread showing memory usage, height represents total memory consumption per thread."
            };
            const descElement = document.getElementById('landscape-description');
            if (descElement) {
                descElement.innerHTML = `<p>${descriptions[viewType]}</p>`;
            }
            
            // Switch view
            if (window.memoryLandscape) {
                window.memoryLandscape.currentView = viewType;
                window.memoryLandscape.renderLandscape();
            }
        };
        
        window.animateLandscape = function() {
            if (window.memoryLandscape) {
                window.memoryLandscape.isAnimating = true;
                window.memoryLandscape.renderLandscape();
                setTimeout(() => {
                    if (window.memoryLandscape) {
                        window.memoryLandscape.isAnimating = false;
                    }
                }, 2000);
            }
        };
        
        // Initialize landscape system
        setTimeout(() => {
            if (window.memoryLandscape && window.memoryLandscape.init) {
                window.memoryLandscape.init();
            }
        }, 1000);
        
        // All Three.js related code removed
        // Now using simple CSS+JavaScript implementation, no complex 3D libraries needed
        
        // Cross-Process Analysis Functions
        
        function crossProcessAnalysis() {
            console.log('Cross-process analysis functionality preserved');
        }
        
        // End of functional code - removed all Three.js residual code
        
        // 3D View Control Functions (legacy - to be removed)
        window.switch3DView = function(viewType) {
                
                // Group variables by thread (floors)
                const threadGroups = {};
                this.memoryData.forEach(variable => {
                    if (!threadGroups[variable.threadId]) {
                        threadGroups[variable.threadId] = [];
                    }
                    threadGroups[variable.threadId].push(variable);
                });
                
                // Create building floors for each thread
                Object.keys(threadGroups).forEach((threadId, floorIndex) => {
                    const variables = threadGroups[threadId];
                    const floorY = floorIndex * 3;
                    
                    // Create floor base
                    const floorGeometry = new THREE.BoxGeometry(8, 0.2, 6);
                    const floorMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0x444444,
                        transparent: true,
                        opacity: 0.7
                    });
                    const floor = new THREE.Mesh(floorGeometry, floorMaterial);
                    floor.position.set(0, floorY, 0);
                    floor.castShadow = true;
                    floor.receiveShadow = true;
                    this.scene.add(floor);
                    
                    // Add floor label
                    this.addFloorLabel(`Thread ${threadId}`, 0, floorY + 1, -4);
                    
                    // Create variable blocks on this floor
                    variables.forEach((variable, index) => {
                        const height = Math.log(variable.size / 100 + 1) * 2; // Logarithmic height scaling
                        const geometry = new THREE.BoxGeometry(0.8, height, 0.8);
                        const material = new THREE.MeshLambertMaterial({ 
                            color: variable.health.color,
                            transparent: true,
                            opacity: 0.8
                        });
                        
                        const cube = new THREE.Mesh(geometry, material);
                        cube.position.set(
                            variable.x,
                            floorY + height / 2 + 0.1,
                            variable.z
                        );
                        cube.castShadow = true;
                        cube.userData = variable; // Store variable data for inspection
                        
                        this.scene.add(cube);
                        this.memoryObjects.push(cube);
                    });
                });
        }
        
        // Landscape control functions
        
        // Cross-Process Analysis Functions
        
        // Cross-Process Analysis Functions
        window.showCrossTab = function(tabName, event) {
            // Hide all cross-content
            document.querySelectorAll('.cross-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // Remove active from all tabs
            document.querySelectorAll('.cross-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Show selected content and tab
            const contentElement = document.getElementById(tabName + '-content');
            if (contentElement) {
                contentElement.classList.add('active');
            }
            
            // Add active to clicked tab
            if (event && event.target) {
                event.target.classList.add('active');
            }
            
            // Initialize visualizations for the selected tab
            initTabVisualization(tabName);
        };
        
        function initTabVisualization(tabName) {
            switch(tabName) {
                case 'competitions':
                    setTimeout(() => drawVariableCompetitionChart(), 100);
                    break;
                case 'shared-memory':
                    setTimeout(() => drawMemoryAccessHeatmap(), 100);
                    break;
                case 'bottlenecks':
                    setTimeout(() => drawSyncTimeline(), 100);
                    break;
                case 'relationships':
                    setTimeout(() => drawDependencyGraph(), 100);
                    break;
            }
        }

        // Cross-process visualization functions
        function drawVariableCompetitionChart() {
            console.log('Drawing variable competition chart');
            const container = document.getElementById('competitions-content');
            if (!container) return;
            
            // Create or find chart container
            let chartContainer = container.querySelector('.competition-chart-container');
            if (!chartContainer) {
                chartContainer = document.createElement('div');
                chartContainer.className = 'competition-chart-container';
                chartContainer.style.cssText = 'margin-top: 20px; padding: 15px; background: var(--card-bg); border-radius: 8px; border: 1px solid var(--border);';
                container.appendChild(chartContainer);
            }
            
            const canvas = chartContainer.querySelector('canvas') || document.createElement('canvas');
            canvas.width = 600;
            canvas.height = 350;
            canvas.style.cssText = 'border: 1px solid var(--border); border-radius: 4px; background: var(--bg);';
            if (!chartContainer.querySelector('canvas')) {
                chartContainer.appendChild(canvas);
            }
            
            const ctx = canvas.getContext('2d');
            const isDarkMode = document.body.classList.contains('dark-theme') || 
                               window.matchMedia('(prefers-color-scheme: dark)').matches;
            
            const colors = {
                bg: '#000000',
                text: '#ffffff',
                grid: '#111111',
                high: '#ff0066',
                medium: '#ffaa00',
                low: '#00ff66'
            };
            
            ctx.clearRect(0, 0, 600, 350);
            
            // Draw modern card-style background with subtle pattern
            const gradient = ctx.createLinearGradient(0, 0, 0, 350);
            gradient.addColorStop(0, colors.bg + 'F0');
            gradient.addColorStop(0.5, colors.bg + 'E0');
            gradient.addColorStop(1, colors.bg + 'D0');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 600, 350);
            
            // Add subtle grid pattern
            ctx.strokeStyle = isDarkMode ? '#2a2a2a' : '#f5f5f5';
            ctx.lineWidth = 0.5;
            for (let i = 0; i < 600; i += 40) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, 350);
                ctx.stroke();
            }
            for (let i = 0; i < 350; i += 40) {
                ctx.beginPath();
                ctx.moveTo(0, i);
                ctx.lineTo(600, i);
                ctx.stroke();
            }
            
            // Modern border
            ctx.strokeStyle = isDarkMode ? '#404040' : '#e0e0e0';
            ctx.lineWidth = 2;
            ctx.strokeRect(1, 1, 598, 348);
            
            // Title with modern font
            ctx.fillStyle = colors.text;
            ctx.font = 'bold 14px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
            ctx.fillText('🥊 Variable Competition Analysis', 20, 30);
            
            // Competition data
            const competitions = [
                { name: 'shared_buffer', contentions: 45, threads: 8, severity: 'high' },
                { name: 'cache_data', contentions: 23, threads: 5, severity: 'medium' },
                { name: 'work_queue', contentions: 12, threads: 3, severity: 'low' },
                { name: 'mutex_lock', contentions: 67, threads: 12, severity: 'high' },
                { name: 'result_store', contentions: 18, threads: 4, severity: 'medium' }
            ];
            
            // Draw bars
            const barWidth = 80;
            const barSpacing = 100;
            const maxContentions = Math.max(...competitions.map(c => c.contentions));
            
            competitions.forEach((comp, i) => {
                const x = 50 + i * barSpacing;
                const barHeight = (comp.contentions / maxContentions) * 200;
                const y = 280 - barHeight;
                
                // Bar color based on severity
                ctx.fillStyle = colors[comp.severity];
                ctx.fillRect(x, y, barWidth, barHeight);
                
                // Add gradient effect
                const gradient = ctx.createLinearGradient(x, y, x, y + barHeight);
                gradient.addColorStop(0, colors[comp.severity] + '80');
                gradient.addColorStop(1, colors[comp.severity]);
                ctx.fillStyle = gradient;
                ctx.fillRect(x, y, barWidth, barHeight);
                
                // Bar border
                ctx.strokeStyle = colors.text;
                ctx.lineWidth = 1;
                ctx.strokeRect(x, y, barWidth, barHeight);
                
                // Values on bars
                ctx.fillStyle = colors.text;
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(comp.contentions.toString(), x + barWidth/2, y - 5);
                ctx.fillText(`${comp.threads} threads`, x + barWidth/2, y - 20);
                
                // Variable names
                ctx.font = '10px Arial';
                ctx.fillText(comp.name, x + barWidth/2, 300);
            });
            
            // Legend
            ctx.textAlign = 'left';
            ctx.font = '12px Arial';
            ctx.fillStyle = colors.high;
            ctx.fillRect(20, 320, 15, 15);
            ctx.fillStyle = colors.text;
            ctx.fillText('High Contention (>40)', 40, 332);
            
            ctx.fillStyle = colors.medium;
            ctx.fillRect(180, 320, 15, 15);
            ctx.fillStyle = colors.text;
            ctx.fillText('Medium (20-40)', 200, 332);
            
            ctx.fillStyle = colors.low;
            ctx.fillRect(320, 320, 15, 15);
            ctx.fillStyle = colors.text;
            ctx.fillText('Low (<20)', 340, 332);
        }

        function drawMemoryAccessHeatmap() {
            console.log('Drawing interactive memory access heatmap');
            const canvas = document.getElementById('memory-access-heatmap');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const isDarkMode = document.body.classList.contains('dark-theme') || 
                               window.matchMedia('(prefers-color-scheme: dark)').matches;
            
            const colors = {
                bg: '#000000',
                text: '#ffffff',
                readOnly: '#00ff88',
                writeHeavy: '#ff0066',
                mixed: '#ffaa00'
            };
            
            ctx.clearRect(0, 0, 600, 350);
            
            // Draw modern card-style background
            const gradient = ctx.createLinearGradient(0, 0, 0, 350);
            gradient.addColorStop(0, colors.bg + 'CC');
            gradient.addColorStop(1, colors.bg + '99');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 600, 350);
            
            // Add subtle border
            ctx.strokeStyle = isDarkMode ? '#333' : '#ddd';
            ctx.lineWidth = 1;
            ctx.strokeRect(0, 0, 600, 350);
            
            // Title with better styling
            ctx.fillStyle = colors.text;
            ctx.font = 'bold 14px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
            ctx.fillText('📊 Memory Access Patterns', 20, 30);
            
            // Create heatmap grid
            const gridSize = 20;
            const rows = 12;
            const cols = 25;
            
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const x = 50 + col * gridSize;
                    const y = 60 + row * gridSize;
                    
                    // Simulate access intensity
                    const intensity = Math.random();
                    let color;
                    
                    if (intensity > 0.7) {
                        color = colors.writeHeavy;
                    } else if (intensity > 0.4) {
                        color = colors.mixed;
                    } else {
                        color = colors.readOnly;
                    }
                    
                    ctx.fillStyle = color + Math.floor(intensity * 255).toString(16).padStart(2, '0');
                    ctx.fillRect(x, y, gridSize - 1, gridSize - 1);
                }
            }
            
            // Legend
            ctx.fillStyle = colors.text;
            ctx.font = '12px Arial';
            ctx.fillText('Memory Access Intensity:', 50, 320);
            
            ctx.fillStyle = colors.readOnly;
            ctx.fillRect(50, 330, 20, 15);
            ctx.fillStyle = colors.text;
            ctx.fillText('Read-Only', 75, 342);
            
            ctx.fillStyle = colors.mixed;
            ctx.fillRect(160, 330, 20, 15);
            ctx.fillText('Mixed Access', 185, 342);
            
            ctx.fillStyle = colors.writeHeavy;
            ctx.fillRect(290, 330, 20, 15);
            ctx.fillText('Write-Heavy', 315, 342);
            
            // Add mouse interaction for heatmap
            let heatmapData = [];
            let currentHeatmapMode = 'all';
            
            // Store grid data for interaction
            for (let row = 0; row < 12; row++) {
                heatmapData[row] = [];
                for (let col = 0; col < 25; col++) {
                    const intensity = Math.random();
                    let type = intensity > 0.7 ? 'write' : intensity > 0.4 ? 'mixed' : 'read';
                    heatmapData[row][col] = { intensity, type, processes: Math.floor(Math.random() * 5) + 1 };
                }
            }
            
            // Mouse interaction for heatmap
            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left - 50;
                const y = e.clientY - rect.top - 60;
                
                if (x >= 0 && y >= 0 && x < 500 && y < 240) {
                    const col = Math.floor(x / 20);
                    const row = Math.floor(y / 20);
                    
                    if (row < 12 && col < 25 && heatmapData[row] && heatmapData[row][col]) {
                        const cell = heatmapData[row][col];
                        const info = `Cell [${row},${col}]: ${cell.type} access, ${cell.processes} processes, intensity: ${Math.round(cell.intensity * 100)}%`;
                        document.getElementById('heatmap-hover-info').textContent = info;
                        canvas.style.cursor = 'pointer';
                    }
                } else {
                    document.getElementById('heatmap-hover-info').textContent = 'Hover over cells for details';
                    canvas.style.cursor = 'crosshair';
                }
            });
            
            canvas.addEventListener('click', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left - 50;
                const y = e.clientY - rect.top - 60;
                
                if (x >= 0 && y >= 0 && x < 500 && y < 240) {
                    const col = Math.floor(x / 20);
                    const row = Math.floor(y / 20);
                    
                    if (row < 12 && col < 25) {
                        console.log(`Clicked heatmap cell [${row},${col}]`, heatmapData[row][col]);
                        // Could show detailed popup here
                    }
                }
            });
        }
        
        // Heatmap interaction functions
        function toggleHeatmapMode() {
            const modes = ['all', 'intensity', 'processes'];
            const currentIndex = modes.indexOf(currentHeatmapMode);
            currentHeatmapMode = modes[(currentIndex + 1) % modes.length];
            console.log('Heatmap mode changed to:', currentHeatmapMode);
            drawMemoryAccessHeatmap(); // Redraw with new mode
        }
        
        function filterHeatmapByProcess(value) {
            console.log('Filtering heatmap by:', value);
            // Implement filtering logic
            drawMemoryAccessHeatmap();
        }

        function drawSyncTimeline() {
            console.log('Drawing interactive sync timeline');
            const canvas = document.getElementById('sync-timeline');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const isDarkMode = document.body.classList.contains('dark-theme') || 
                               window.matchMedia('(prefers-color-scheme: dark)').matches;
            
            // Store for global use
            timelineCanvas = canvas;
            isDarkModeGlobal = isDarkMode;
            
            const colors = {
                bg: '#000000',
                text: '#ffffff',
                thread1: '#ff0066',
                thread2: '#00ff88', 
                thread3: '#0088ff',
                sync: '#ffaa00'
            };
            
            const width = canvas.width;
            const height = canvas.height;
            
            ctx.clearRect(0, 0, width, height);
            
            // Draw modern timeline background
            const timelineGradient = ctx.createRadialGradient(width/2, height/2, 0, width/2, height/2, height/2);
            timelineGradient.addColorStop(0, colors.bg + 'F0');
            timelineGradient.addColorStop(0.7, colors.bg + 'CC');
            timelineGradient.addColorStop(1, colors.bg + '99');
            ctx.fillStyle = timelineGradient;
            ctx.fillRect(0, 0, width, height);
            
            // Add timeline background pattern
            ctx.strokeStyle = '#111111';
            ctx.lineWidth = 1;
            for (let i = 100; i <= width - 100; i += 50) {
                ctx.beginPath();
                ctx.moveTo(i, 50);
                ctx.lineTo(i, height - 50);
                ctx.stroke();
            }
            
            // Modern card border
            ctx.strokeStyle = '#333333';
            ctx.lineWidth = 1;
            ctx.strokeRect(0, 0, width, height);
            
            // Title with icon
            ctx.fillStyle = colors.text;
            ctx.font = 'bold 14px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
            ctx.fillText('⏱️ Synchronization Timeline', 20, 30);
            
            // Timeline (expanded to use full width)
            const timelineY = 100;
            const timelineWidth = width - 200; // Use almost full width
            const threadHeight = 80; // Increase thread spacing
            const threads = ['Thread 1', 'Thread 2', 'Thread 3', 'Thread 4', 'Thread 5'];
            const threadColors = [colors.thread1, colors.thread2, colors.thread3, '#ff6600', '#9900ff'];
            
            threads.forEach((thread, i) => {
                const y = timelineY + i * threadHeight;
                
                // Thread label
                ctx.fillStyle = colors.text;
                ctx.font = '12px Arial';
                ctx.fillText(thread, 20, y - 5);
                
                // Timeline base
                ctx.strokeStyle = threadColors[i];
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(100, y);
                ctx.lineTo(100 + timelineWidth, y);
                ctx.stroke();
                
                // Synchronization events
                const events = [
                    { time: 0.2, duration: 0.1, type: 'mutex' },
                    { time: 0.5, duration: 0.15, type: 'wait' },
                    { time: 0.8, duration: 0.05, type: 'mutex' }
                ];
                
                events.forEach(event => {
                    const x = 100 + event.time * timelineWidth;
                    const width = event.duration * timelineWidth;
                    
                    ctx.fillStyle = colors.sync;
                    ctx.fillRect(x, y - 8, width, 16);
                    
                    ctx.strokeStyle = colors.text;
                    ctx.lineWidth = 1;
                    ctx.strokeRect(x, y - 8, width, 16);
                });
            });
            
            // Time markers (adjusted for larger canvas)
            ctx.fillStyle = colors.text;
            ctx.font = '12px Arial';
            for (let i = 0; i <= 10; i++) {
                const x = 100 + (i / 10) * timelineWidth;
                ctx.fillText(`${i * 100}ms`, x - 10, height - 20);
                
                ctx.strokeStyle = colors.text + '40';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x, timelineY - 20);
                ctx.lineTo(x, timelineY + (threadHeight * threads.length) + 20);
                ctx.stroke();
            }
            
            // Note: Timeline interaction state moved to global scope
            
            // Add click interaction for timeline
            canvas.addEventListener('click', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // Check if click is in timeline area
                if (x >= 100 && x <= 600 && y >= 80 && y <= 260) {
                    const timePercent = (x - 100) / 500;
                    currentTimePosition = timePercent * 1000;
                    document.getElementById('timeline-time').textContent = `${Math.round(currentTimePosition)}ms`;
                    document.getElementById('timeline-slider').value = currentTimePosition;
                    
                    // Highlight events at this time
                    highlightTimelineEvents(timePercent);
                    console.log(`Timeline clicked at ${Math.round(currentTimePosition)}ms`);
                }
            });
            
            // Note: highlightTimelineEvents function moved to global scope
        }
        
        // Global timeline variables and functions (moved outside drawSyncTimeline)
        let currentTimePosition = 0;
        let isPlaying = false;
        let animationId = null;
        let timelineCanvas = null;
        let isDarkModeGlobal = false;
        
        function highlightTimelineEvents(timePercent) {
            if (!timelineCanvas) {
                timelineCanvas = document.getElementById('sync-timeline');
                if (!timelineCanvas) return;
            }
            
            // Redraw timeline with highlighted events at current time
            const ctx = timelineCanvas.getContext('2d');
            
            const colors = {
                bg: '#000000',
                text: '#ffffff',
                thread1: '#ff0066',
                thread2: '#00ff88', 
                thread3: '#0088ff',
                sync: '#ffaa00',
                highlight: '#ffffff'
            };
            
            // Redraw the entire timeline first
            drawSyncTimeline();
            
            // Draw time cursor
            const cursorX = 100 + timePercent * 500;
            ctx.strokeStyle = colors.highlight;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(cursorX, 60);
            ctx.lineTo(cursorX, 280);
            ctx.stroke();
            
            // Highlight current time text
            ctx.fillStyle = colors.highlight;
            ctx.font = 'bold 12px Arial';
            ctx.fillText(`⏰ ${Math.round(timePercent * 1000)}ms`, cursorX - 30, 50);
        }

        // Timeline interaction functions
        function toggleTimelineMode() {
            console.log('Toggling timeline view mode');
            // Could switch between thread view and event view
            drawSyncTimeline();
        }
        
        function toggleGraphMode() {
            const button = event.target;
            const currentMode = button.textContent.trim();
            
            if (currentMode === 'Network View') {
                button.textContent = 'Tree View';
                showNetworkView();
            } else {
                button.textContent = 'Network View';
                showTreeView();
            }
        }
        
        function showNetworkView() {
            console.log('Switching to network view');
            // Implement network visualization
        }
        
        function showTreeView() {
            console.log('Switching to tree view');
            // Implement tree visualization
        }

        function drawDependencyGraph() {
            console.log('Drawing interactive dependency graph');
            const canvas = document.getElementById('dependency-graph');
            if (!canvas) return;
            
            // Set canvas size with proper DPI scaling for crisp display
            canvas.width = 1200;
            canvas.height = 800;
            canvas.style.width = '800px';
            canvas.style.height = '533px';
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            // Clear canvas
            ctx.clearRect(0, 0, width, height);
            
            // Detect dark mode
            const isDarkMode = document.body.classList.contains('dark-theme') || 
                               window.matchMedia('(prefers-color-scheme: dark)').matches ||
                               getComputedStyle(document.body).backgroundColor === 'rgb(33, 37, 41)';
            
            // Set colors based on theme
            const colors = {
                background: '#000000',
                node: '#00ff88',
                nodeHover: '#44ffaa',
                edge: '#888888',
                edgeActive: '#00ffff',
                text: '#ffffff',
                textSecondary: '#cccccc'
            };
            
            // Enhanced nodes with real variable data (expanded layout)
            const nodes = [
                { name: 'shared_buffer', x: 150, y: 120, connections: [1, 2], size: 25, type: 'buffer' },
                { name: 'cache_data', x: 400, y: 150, connections: [2, 3], size: 22, type: 'cache' },
                { name: 'work_queue', x: 300, y: 280, connections: [3, 4], size: 24, type: 'queue' },
                { name: 'mutex_lock', x: 550, y: 220, connections: [0], size: 20, type: 'sync' },
                { name: 'result_store', x: 150, y: 350, connections: [0, 2], size: 21, type: 'storage' },
                { name: 'thread_pool', x: 650, y: 150, connections: [1, 4], size: 23, type: 'thread' },
                { name: 'memory_arena', x: 450, y: 400, connections: [2, 5], size: 26, type: 'memory' },
                { name: 'async_queue', x: 200, y: 480, connections: [4, 6], size: 19, type: 'async' }
            ];
            
            // Add hover and click interaction state
            let hoveredNode = -1;
            let selectedNode = -1;
            
            function drawGraph() {
                ctx.clearRect(0, 0, width, height);
                
                // Draw modern dependency graph background
                const depGradient = ctx.createLinearGradient(0, 0, width, height);
                depGradient.addColorStop(0, colors.background + 'F5');
                depGradient.addColorStop(0.3, colors.background + 'E8');
                depGradient.addColorStop(0.7, colors.background + 'DD');
                depGradient.addColorStop(1, colors.background + 'CC');
                ctx.fillStyle = depGradient;
                ctx.fillRect(0, 0, width, height);
                
                // Add subtle mesh pattern for nodes
                ctx.strokeStyle = isDarkMode ? '#1a1a1a' : '#f8f9fa';
                ctx.lineWidth = 0.3;
                for (let i = 0; i < width; i += 30) {
                    for (let j = 0; j < height; j += 30) {
                        ctx.beginPath();
                        ctx.arc(i, j, 1, 0, 2 * Math.PI);
                        ctx.stroke();
                    }
                }
                
                // Modern card border
                ctx.strokeStyle = isDarkMode ? '#404040' : '#dee2e6';
                ctx.lineWidth = 1;
                ctx.strokeRect(0, 0, width, height);
                
                // Title with modern styling
                ctx.fillStyle = colors.text;
                ctx.font = 'bold 13px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                ctx.fillText('🕸️ Variable Dependency Graph', 10, 25);
                
                // Draw edges first
                ctx.lineWidth = 2;
                nodes.forEach((node, i) => {
                    node.connections.forEach(connIndex => {
                        if (connIndex < nodes.length) {
                            const target = nodes[connIndex];
                            const isActive = selectedNode === i || selectedNode === connIndex || 
                                           hoveredNode === i || hoveredNode === connIndex;
                            
                            // Draw modern connection lines with gradient
                            const lineGradient = ctx.createLinearGradient(node.x, node.y, target.x, target.y);
                            const edgeColor = isActive ? colors.edgeActive : colors.edge;
                            lineGradient.addColorStop(0, edgeColor + 'DD');
                            lineGradient.addColorStop(0.5, edgeColor + 'AA');
                            lineGradient.addColorStop(1, edgeColor + 'DD');
                            ctx.strokeStyle = lineGradient;
                            ctx.lineWidth = isActive ? 3 : 1.5;
                            
                            // Add line cap for smoother appearance
                            ctx.lineCap = 'round';
                            ctx.beginPath();
                            ctx.moveTo(node.x, node.y);
                            ctx.lineTo(target.x, target.y);
                            ctx.stroke();
                            
                            // Draw edge weight
                            if (isActive) {
                                const midX = (node.x + target.x) / 2;
                                const midY = (node.y + target.y) / 2;
                                ctx.fillStyle = colors.edgeActive;
                                ctx.font = '10px Arial';
                                ctx.fillText('87%', midX - 10, midY - 5);
                            }
                        }
                    });
                });
                
                // Draw nodes
                nodes.forEach((node, i) => {
                    const isHovered = hoveredNode === i;
                    const isSelected = selectedNode === i;
                    const nodeSize = node.size + (isHovered ? 4 : 0) + (isSelected ? 6 : 0);
                    
                    // Node shadow for depth
                    if (isHovered || isSelected) {
                        ctx.shadowColor = colors.node;
                        ctx.shadowBlur = 10;
                        ctx.shadowOffsetX = 2;
                        ctx.shadowOffsetY = 2;
                    }
                    
                    // Draw modern node with gradient
                    const nodeGradient = ctx.createRadialGradient(node.x, node.y, 0, node.x, node.y, nodeSize);
                    const nodeColor = isHovered || isSelected ? colors.nodeHover : colors.node;
                    nodeGradient.addColorStop(0, nodeColor);
                    nodeGradient.addColorStop(0.7, nodeColor + 'DD');
                    nodeGradient.addColorStop(1, nodeColor + 'BB');
                    ctx.fillStyle = nodeGradient;
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, nodeSize, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Modern node border with glow effect
                    if (isSelected || isHovered) {
                        ctx.shadowColor = colors.node;
                        ctx.shadowBlur = 8;
                        ctx.shadowOffsetX = 0;
                        ctx.shadowOffsetY = 0;
                    }
                    ctx.strokeStyle = isSelected ? colors.nodeHover : (colors.text + '80');
                    ctx.lineWidth = isSelected ? 2 : 1;
                    ctx.stroke();
                    
                    // Reset shadow
                    ctx.shadowBlur = 0;
                    
                    // Reset shadow
                    ctx.shadowBlur = 0;
                    ctx.shadowOffsetX = 0;
                    ctx.shadowOffsetY = 0;
                    
                    // Node type indicator
                    ctx.fillStyle = colors.background;
                    ctx.font = '16px Arial';
                    const typeSymbols = {
                        'buffer': '📦',
                        'cache': '💾',
                        'queue': '📋',
                        'sync': '🔒',
                        'storage': '🗄️',
                        'thread': '🧵',
                        'memory': '🧠',
                        'async': '⚡'
                    };
                    ctx.fillText(typeSymbols[node.type] || '●', node.x - 8, node.y + 6);
                    
                    // Node label
                    ctx.fillStyle = colors.text;
                    ctx.font = isSelected ? 'bold 11px Arial' : '10px Arial';
                    const textWidth = ctx.measureText(node.name).width;
                    ctx.fillText(node.name, node.x - textWidth / 2, node.y + nodeSize + 15);
                    
                    // Show detailed info for selected/hovered node
                    if (isHovered || isSelected) {
                        // Node details background
                        const infoWidth = 180;
                        const infoHeight = 80;
                        const infoX = node.x + nodeSize + 10;
                        const infoY = node.y - infoHeight / 2;
                        
                        // Draw info background
                        ctx.fillStyle = colors.background + 'E0';
                        ctx.fillRect(infoX, infoY, infoWidth, infoHeight);
                        ctx.strokeStyle = colors.edgeActive;
                        ctx.lineWidth = 2;
                        ctx.strokeRect(infoX, infoY, infoWidth, infoHeight);
                        
                        // Node info text
                        ctx.fillStyle = colors.text;
                        ctx.font = 'bold 12px Arial';
                        ctx.fillText(`${node.name}`, infoX + 8, infoY + 16);
                        
                        ctx.font = '10px Arial';
                        ctx.fillStyle = colors.textSecondary;
                        ctx.fillText(`Type: ${node.type}`, infoX + 8, infoY + 32);
                        ctx.fillText(`Connections: ${node.connections.length}`, infoX + 8, infoY + 46);
                        ctx.fillText(`Size: ${node.size}px`, infoX + 8, infoY + 60);
                        
                        // Show connected nodes
                        if (node.connections.length > 0) {
                            const connectedNames = node.connections.map(i => nodes[i]?.name || 'unknown').join(', ');
                            ctx.fillText(`→ ${connectedNames}`, infoX + 8, infoY + 74);
                        }
                    }
                });
                
                // Instructions and status
                ctx.fillStyle = colors.textSecondary;
                ctx.font = '10px Arial';
                ctx.fillText('Click nodes to select • Hover for details • Drag to move', 10, height - 25);
                
                // Show current hover/selection status
                if (hoveredNode >= 0) {
                    ctx.fillStyle = colors.edgeActive;
                    ctx.font = 'bold 11px Arial';
                    ctx.fillText(`Hovering: ${nodes[hoveredNode].name}`, 10, height - 10);
                } else if (selectedNode >= 0) {
                    ctx.fillStyle = colors.nodeHover;
                    ctx.font = 'bold 11px Arial';
                    ctx.fillText(`Selected: ${nodes[selectedNode].name}`, 10, height - 10);
                } else {
                    ctx.fillStyle = colors.textSecondary;
                    ctx.font = '10px Arial';
                    ctx.fillText('Hover over nodes to see details', 10, height - 10);
                }
            }
            
            // Mouse interaction
            function getMousePos(e) {
                const rect = canvas.getBoundingClientRect();
                return {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
            }
            
            function getNodeAt(x, y) {
                // Account for canvas scaling
                const scaleX = canvas.width / canvas.offsetWidth;
                const scaleY = canvas.height / canvas.offsetHeight;
                const scaledX = x * scaleX;
                const scaledY = y * scaleY;
                
                for (let i = 0; i < nodes.length; i++) {
                    const node = nodes[i];
                    const distance = Math.sqrt((scaledX - node.x) ** 2 + (scaledY - node.y) ** 2);
                    if (distance <= node.size + 10) { // Increased hit area
                        return i;
                    }
                }
                return -1;
            }
            
            // Event listeners
            canvas.addEventListener('mousemove', (e) => {
                const pos = getMousePos(e);
                const newHoveredNode = getNodeAt(pos.x, pos.y);
                
                if (newHoveredNode !== hoveredNode) {
                    hoveredNode = newHoveredNode;
                    canvas.style.cursor = hoveredNode >= 0 ? 'pointer' : 'default';
                    drawGraph();
                }
            });
            
            canvas.addEventListener('click', (e) => {
                const pos = getMousePos(e);
                const clickedNode = getNodeAt(pos.x, pos.y);
                
                if (clickedNode >= 0) {
                    selectedNode = selectedNode === clickedNode ? -1 : clickedNode;
                    drawGraph();
                    
                    // Show node details in console or popup
                    if (selectedNode >= 0) {
                        console.log(`Selected: ${nodes[selectedNode].name}`, {
                            type: nodes[selectedNode].type,
                            connections: nodes[selectedNode].connections.map(i => nodes[i].name)
                        });
                    }
                }
            });
            
            canvas.addEventListener('mouseleave', () => {
                hoveredNode = -1;
                canvas.style.cursor = 'default';
                drawGraph();
            });
            
            // Initial draw
            drawGraph();
        }
        
        
        function showInsightTab(tabName) {
           
            document.querySelectorAll('.insight-content').forEach(content => {
                content.classList.remove('active');
            });
            
            
            document.querySelectorAll('.insight-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            
            document.getElementById(tabName + '-content').classList.add('active');
            event.target.classList.add('active');
        }
        
        
        function analyzeBottleneck() {
            // Extract real data from page instead of relying on undefined DASHBOARD_DATA
            const bottleneckInfo = extractBottleneckInfo();
            showNotification('🔍 Analyzing bottleneck... Check console for detailed analysis');
            console.log('📊 Bottleneck Analysis:', bottleneckInfo);
            
            // Show more detailed analysis
            showDetailedBottleneckAnalysis(bottleneckInfo);
        }
        
        function extractBottleneckInfo() {
            // Extract actual performance data from DOM
            const performanceAlert = document.querySelector('.performance-alert');
            if (!performanceAlert) {
                return {
                    threadId: 'No bottleneck detected',
                    allocationRate: '0',
                    location: 'N/A',
                    analysis: 'System performance is optimal'
                };
            }
            
            const alertText = performanceAlert.textContent;
            const threadMatch = alertText.match(/Thread (\d+)/);
            const rateMatch = alertText.match(/([\d,]+) allocations\/sec/);
            const percentMatch = alertText.match(/(\d+)% above average/);
            
            return {
                threadId: threadMatch ? threadMatch[1] : 'Multiple threads',
                allocationRate: rateMatch ? rateMatch[1] : 'High',
                location: 'execute_track_var_workload()',
                percentAboveAverage: percentMatch ? percentMatch[1] : '0',
                analysis: generateBottleneckAnalysis(threadMatch, rateMatch, percentMatch)
            };
        }
        
        function generateBottleneckAnalysis(threadMatch, rateMatch, percentMatch) {
            if (!threadMatch) {
                return 'Performance is well-balanced across all threads';
            }
            
            const threadId = threadMatch[1];
            const rate = rateMatch ? rateMatch[1] : 'high';
            const percent = percentMatch ? percentMatch[1] : '0';
            
            let analysis = `Thread ${threadId} is experiencing elevated allocation activity. `;
            
            if (parseInt(percent) > 200) {
                analysis += 'This is a critical performance bottleneck that requires immediate attention. ';
                analysis += 'Recommendations: 1) Review loop allocations, 2) Consider pre-allocation, 3) Check for memory leaks.';
            } else if (parseInt(percent) > 100) {
                analysis += 'This is a moderate performance concern. ';
                analysis += 'Recommendations: 1) Optimize allocation patterns, 2) Use object pooling, 3) Consider lazy initialization.';
            } else {
                analysis += 'This is within acceptable performance ranges but worth monitoring.';
            }
            
            return analysis;
        }
        
        function showDetailedBottleneckAnalysis(info) {
            // Create detailed analysis popup
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.7); z-index: 2000; display: flex;
                align-items: center; justify-content: center;
            `;
            
            modal.innerHTML = `
                <div style="background: var(--bg); padding: 30px; border-radius: 12px; max-width: 600px; max-height: 80vh; overflow-y: auto;">
                    <h3 style="margin-top: 0; color: var(--primary);">🔍 Detailed Bottleneck Analysis</h3>
                    <div style="margin: 20px 0;">
                        <strong>Thread ID:</strong> ${info.threadId}<br>
                        <strong>Allocation Rate:</strong> ${info.allocationRate}<br>
                        <strong>Location:</strong> ${info.location}<br>
                        ${info.percentAboveAverage ? `<strong>Above Average:</strong> ${info.percentAboveAverage}%<br>` : ''}
                    </div>
                    <div style="background: var(--bg2); padding: 15px; border-radius: 8px; margin: 15px 0;">
                        <strong>Analysis:</strong><br>
                        ${info.analysis}
                    </div>
                    <div style="background: var(--bg2); padding: 15px; border-radius: 8px; margin: 15px 0;">
                        <strong>🔧 Suggested Optimizations:</strong><br>
                        • Use Vec::with_capacity() for known sizes<br>
                        • Consider String::with_capacity() for string building<br>
                        • Review loop-based allocations<br>
                        • Implement object pooling for frequently allocated objects
                    </div>
                    <button onclick="this.parentElement.parentElement.remove()" 
                            style="background: var(--primary); color: white; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer; float: right;">
                        Close
                    </button>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Click background to close
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            });
        }

        // Initialize mini charts
        function initializeMiniCharts() {
            // Clone trend chart
            initCloningTrendChart();
            
            // Contention timeline chart
            initContentionTimelineChart();
            
            // Allocation spike chart
            initAllocationSpikeChart();
        }

        function initCloningTrendChart() {
            const canvas = document.getElementById('cloning-trend-chart');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            // Simulate clone trend data
            const data = [2, 3, 5, 12, 25, 18, 8, 4, 2, 1]; // Clone count
            const max = Math.max(...data);
            
            // Draw background
            ctx.fillStyle = 'rgba(59, 130, 246, 0.1)';
            ctx.fillRect(0, 0, width, height);
            
            // Draw trend line
            ctx.strokeStyle = '#3b82f6';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            data.forEach((value, index) => {
                const x = (index / (data.length - 1)) * width;
                const y = height - (value / max) * height;
                
                if (index === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });
            
            ctx.stroke();
            
            // Mark peak points
            const peakIndex = data.indexOf(max);
            const peakX = (peakIndex / (data.length - 1)) * width;
            const peakY = height - (max / max) * height;
            
            ctx.fillStyle = '#ef4444';
            ctx.beginPath();
            ctx.arc(peakX, peakY, 3, 0, 2 * Math.PI);
            ctx.fill();
        }

        function initContentionTimelineChart() {
            const canvas = document.getElementById('contention-timeline-chart');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            // Simulate contention data (wait time)
            const waitTimes = [0, 1, 3, 8, 15, 12, 6, 2, 0, 1]; // milliseconds
            const max = Math.max(...waitTimes);
            
            // Draw background
            ctx.fillStyle = 'rgba(245, 158, 11, 0.1)';
            ctx.fillRect(0, 0, width, height);
            
            // Draw bar chart
            waitTimes.forEach((waitTime, index) => {
                const barWidth = width / waitTimes.length;
                const barHeight = (waitTime / max) * height;
                const x = index * barWidth;
                const y = height - barHeight;
                
                // Set color based on wait time
                if (waitTime > 10) {
                    ctx.fillStyle = '#ef4444'; // Red - severe contention
                } else if (waitTime > 5) {
                    ctx.fillStyle = '#f59e0b'; // Orange - moderate contention
                } else {
                    ctx.fillStyle = '#10b981'; // Green - light contention
                }
                
                ctx.fillRect(x, y, barWidth - 1, barHeight);
            });
        }

        function initAllocationSpikeChart() {
            const canvas = document.getElementById('allocation-spike-chart');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            // Simulate memory allocation data (MB)
            const allocations = [1, 1.2, 1.5, 2.1, 8.5, 3.2, 1.8, 1.3, 1.1, 1.0]; // MB
            const max = Math.max(...allocations);
            
            // Draw background
            ctx.fillStyle = 'rgba(16, 185, 129, 0.1)';
            ctx.fillRect(0, 0, width, height);
            
            // Draw area chart
            ctx.fillStyle = 'rgba(59, 130, 246, 0.3)';
            ctx.strokeStyle = '#3b82f6';
            ctx.lineWidth = 2;
            
            ctx.beginPath();
            ctx.moveTo(0, height);
            
            allocations.forEach((value, index) => {
                const x = (index / (allocations.length - 1)) * width;
                const y = height - (value / max) * height;
                ctx.lineTo(x, y);
            });
            
            ctx.lineTo(width, height);
            ctx.closePath();
            ctx.fill();
            
            // Draw border line
            ctx.beginPath();
            allocations.forEach((value, index) => {
                const x = (index / (allocations.length - 1)) * width;
                const y = height - (value / max) * height;
                
                if (index === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });
            ctx.stroke();
            
            // Mark spike points
            const spikeIndex = allocations.indexOf(max);
            const spikeX = (spikeIndex / (allocations.length - 1)) * width;
            const spikeY = height - (max / max) * height;
            
            ctx.fillStyle = '#ef4444';
            ctx.beginPath();
            ctx.arc(spikeX, spikeY, 3, 0, 2 * Math.PI);
            ctx.fill();
        }

        // Initialize charts on page load
        document.addEventListener('DOMContentLoaded', function() {
            // Delay chart initialization to ensure DOM is fully loaded
            setTimeout(() => {
                initializeMiniCharts();
            }, 100);
        });
        
        // Helper functions
        function copyToClipboard(text) {
            if (navigator.clipboard) {
                navigator.clipboard.writeText(text).catch(err => {
                    console.error('Failed to copy to clipboard:', err);
                    fallbackCopyToClipboard(text);
                });
            } else {
                fallbackCopyToClipboard(text);
            }
        }
        
        function fallbackCopyToClipboard(text) {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            try {
                document.execCommand('copy');
            } catch (err) {
                console.error('Fallback copy failed:', err);
            }
            document.body.removeChild(textArea);
        }
        
        function showNotification(message) {
            // Create notification element
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: var(--success);
                color: white;
                padding: 12px 16px;
                border-radius: 8px;
                z-index: 1000;
                font-weight: 500;
                box-shadow: 0 4px 12px rgba(0,0,0,0.2);
                animation: slideIn 0.3s ease;
            `;
            notification.textContent = message;
            
            // Add to page
            document.body.appendChild(notification);
            
            // Auto remove after 3 seconds
            setTimeout(() => {
                notification.style.animation = 'slideOut 0.3s ease';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, 3000);
        }
        
        // Add animation styles
        const insightStyles = document.createElement('style');
        insightStyles.textContent = `
            @keyframes slideIn {
                from { transform: translateX(100%); opacity: 0; }
                to { transform: translateX(0); opacity: 1; }
            }
            @keyframes slideOut {
                from { transform: translateX(0); opacity: 1; }
                to { transform: translateX(100%); opacity: 0; }
            }
            
            .insights-tabs {
                display: flex;
                border-bottom: 2px solid var(--border);
                margin-bottom: 20px;
                gap: 8px;
            }
            
            .insight-tab {
                padding: 12px 16px;
                background: none;
                border: none;
                color: var(--text2);
                cursor: pointer;
                border-radius: 8px 8px 0 0;
                transition: all 0.3s ease;
                font-weight: 500;
            }
            
            .insight-tab.active {
                color: var(--primary);
                background: var(--bg2);
                border-bottom: 2px solid var(--primary);
            }
            
            .insight-tab:hover {
                background: var(--bg2);
                color: var(--primary);
            }
            
            .insight-content {
                display: none;
            }
            
            .insight-content.active {
                display: block;
            }

            .hotspot-grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
                gap: 16px;
                margin-bottom: 20px;
            }
            
            .hotspot-card {
                background: var(--bg);
                border: 2px solid transparent;
                border-radius: 8px;
                padding: 16px;
                transition: all 0.3s ease;
            }
            
            .hotspot-card.critical { 
                border-color: var(--danger); 
                background: rgba(239, 68, 68, 0.05);
            }
            .hotspot-card.warning { 
                border-color: var(--warning); 
                background: rgba(245, 158, 11, 0.05);
            }
            .hotspot-card.good { 
                border-color: var(--success); 
                background: rgba(16, 185, 129, 0.05);
            }
            
            .hotspot-header {
                display: flex;
                align-items: center;
                gap: 8px;
                margin-bottom: 12px;
                font-weight: 600;
            }
            
            .code-location {
                background: var(--bg2);
                padding: 8px 12px;
                border-radius: 6px;
                font-family: 'Monaco', 'Consolas', monospace;
                font-size: 0.85em;
                border-left: 3px solid var(--primary);
                margin: 8px 0;
            }
            
            .hotspot-metrics {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-top: 12px;
                font-size: 0.9em;
            }
            
            .metric-badge {
                background: var(--primary);
                color: white;
                padding: 2px 8px;
                border-radius: 12px;
                font-size: 0.8em;
            }
            
            .metric-badge.high { background: var(--danger); }
            .metric-badge.medium { background: var(--warning); }
            .metric-badge.low { background: var(--success); }

            .leak-status {
                display: flex;
                align-items: center;
                gap: 16px;
                padding: 16px;
                background: var(--bg2);
                border-radius: 8px;
                margin-bottom: 16px;
                border-left: 4px solid var(--success);
            }
            
            .leak-status.warning { border-left-color: var(--warning); }
            .leak-status.critical { border-left-color: var(--danger); }
            
            .leak-icon {
                font-size: 1.5em;
            }

            .suggestion-card {
                background: var(--bg);
                border: 1px solid var(--border);
                border-radius: 8px;
                padding: 16px;
                margin-bottom: 12px;
                border-left: 4px solid var(--primary);
            }
            
            .suggestion-type {
                display: inline-block;
                background: var(--primary);
                color: white;
                padding: 4px 8px;
                border-radius: 4px;
                font-size: 0.8em;
                margin-bottom: 8px;
            }
            
            .suggestion-code {
                background: var(--bg2);
                padding: 12px;
                border-radius: 6px;
                font-family: 'Monaco', 'Consolas', monospace;
                font-size: 0.9em;
                margin: 8px 0;
            }

            .quick-fix-btn {
                background: var(--success);
                color: white;
                border: none;
                padding: 6px 12px;
                border-radius: 4px;
                cursor: pointer;
                font-size: 0.8em;
                margin-top: 8px;
                transition: all 0.2s ease;
            }
            
            .quick-fix-btn:hover {
                opacity: 0.8;
                transform: translateY(-1px);
            }

            .performance-alert {
                background: rgba(239, 68, 68, 0.1);
                border: 1px solid var(--danger);
                border-radius: 8px;
                padding: 16px;
                margin-bottom: 16px;
            }

            .performance-alert.warning {
                background: rgba(245, 158, 11, 0.1);
                border-color: var(--warning);
            }

            .performance-alert.info {
                background: rgba(59, 130, 246, 0.1);
                border-color: var(--primary);
            }
            
            /* Cross-Process Analysis Styles */
            .cross-process-analysis {
                background: var(--bg);
                border: 1px solid var(--border);
                border-radius: 12px;
                padding: 24px;
                margin-bottom: 24px;
            }
            
            .analysis-summary {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                gap: 16px;
                margin-bottom: 24px;
            }
            
            .summary-card {
                background: var(--bg2);
                border: 1px solid var(--border);
                border-radius: 8px;
                padding: 16px;
                display: flex;
                align-items: center;
                gap: 12px;
                transition: transform 0.2s ease;
            }
            
            .summary-card:hover {
                transform: translateY(-2px);
                box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            }
            
            .summary-icon {
                font-size: 1.5em;
                width: 40px;
                text-align: center;
            }
            
            .summary-value {
                font-size: 1.8em;
                font-weight: bold;
                color: var(--primary);
            }
            
            .summary-label {
                font-size: 0.9em;
                color: var(--text2);
            }
            
            .cross-process-tabs {
                display: flex;
                border-bottom: 2px solid var(--border);
                margin-bottom: 20px;
                gap: 4px;
            }
            
            .cross-tab {
                padding: 12px 20px;
                background: none;
                border: none;
                color: var(--text2);
                cursor: pointer;
                border-radius: 8px 8px 0 0;
                transition: all 0.3s ease;
                font-weight: 500;
            }
            
            .cross-tab.active {
                color: var(--primary);
                background: var(--bg2);
                border-bottom: 2px solid var(--primary);
            }
            
            .cross-tab:hover {
                background: var(--bg2);
                color: var(--primary);
            }
            
            .cross-content {
                display: none;
            }
            
            .cross-content.active {
                display: block;
            }
            
            .competition-alerts {
                display: flex;
                flex-direction: column;
                gap: 16px;
            }
            
            .competition-alert {
                border: 2px solid transparent;
                border-radius: 12px;
                padding: 20px;
                background: var(--bg);
            }
            
            .competition-alert.critical {
                border-color: var(--danger);
                background: rgba(239, 68, 68, 0.05);
            }
            
            .competition-alert.warning {
                border-color: var(--warning);
                background: rgba(245, 158, 11, 0.05);
            }
            
            .alert-header {
                display: flex;
                align-items: center;
                gap: 12px;
                margin-bottom: 16px;
                font-size: 1.1em;
            }
            
            .risk-badge {
                margin-left: auto;
                padding: 4px 12px;
                border-radius: 20px;
                font-size: 0.8em;
                font-weight: 600;
            }
            
            .risk-badge.critical {
                background: var(--danger);
                color: white;
            }
            
            .risk-badge.warning {
                background: var(--warning);
                color: white;
            }
            
            .alert-details {
                margin-bottom: 16px;
                line-height: 1.6;
            }
            
            .alert-details ul {
                margin: 8px 0;
                padding-left: 20px;
            }
            
            .alert-solution {
                background: var(--bg2);
                border-radius: 8px;
                padding: 16px;
                border-left: 4px solid var(--primary);
            }
            
            .solution-code {
                background: var(--bg);
                border: 1px solid var(--border);
                border-radius: 6px;
                padding: 12px;
                font-family: 'Monaco', 'Consolas', monospace;
                font-size: 0.9em;
                margin: 8px 0;
                overflow-x: auto;
            }
            
            .memory-pattern-grid {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 24px;
            }
            
            .pattern-visualization,
            .pattern-details {
                background: var(--bg2);
                border-radius: 8px;
                padding: 20px;
            }
            
            .heatmap-legend {
                display: flex;
                justify-content: center;
                gap: 16px;
                margin-top: 12px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                gap: 6px;
                font-size: 0.9em;
            }
            
            .shared-memory-list {
                display: flex;
                flex-direction: column;
                gap: 12px;
            }
            
            .memory-item {
                border: 1px solid var(--border);
                border-radius: 8px;
                padding: 16px;
                background: var(--bg);
            }
            
            .memory-item.high-risk {
                border-left: 4px solid var(--danger);
            }
            
            .memory-item.medium-risk {
                border-left: 4px solid var(--warning);
            }
            
            .memory-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .access-count {
                font-size: 0.9em;
                color: var(--text2);
            }
            
            .memory-processes {
                display: flex;
                gap: 6px;
                margin-bottom: 8px;
                flex-wrap: wrap;
            }
            
            .process-badge {
                background: var(--primary);
                color: white;
                padding: 2px 8px;
                border-radius: 12px;
                font-size: 0.8em;
            }
            
            .memory-risk {
                font-size: 0.9em;
            }
            
            .risk-high {
                color: var(--danger);
                font-weight: bold;
            }
            
            .risk-medium {
                color: var(--warning);
                font-weight: bold;
            }
            
            .bottleneck-timeline {
                background: var(--bg2);
                border-radius: 8px;
                padding: 20px;
                margin-bottom: 24px;
            }
            
            .timeline-controls {
                display: flex;
                justify-content: center;
                gap: 8px;
                margin-top: 12px;
            }
            
            .timeline-btn {
                padding: 6px 12px;
                background: var(--bg);
                border: 1px solid var(--border);
                border-radius: 6px;
                cursor: pointer;
                transition: all 0.2s ease;
            }
            
            .timeline-btn.active {
                background: var(--primary);
                color: white;
                border-color: var(--primary);
            }
            
            .timeline-btn:hover {
                background: var(--primary);
                color: white;
            }
            
            .bottleneck-details {
                background: var(--bg2);
                border-radius: 8px;
                padding: 20px;
            }
            
            .bottleneck-item {
                border: 1px solid var(--border);
                border-radius: 8px;
                padding: 16px;
                background: var(--bg);
            }
            
            .bottleneck-item.severe {
                border-left: 4px solid var(--danger);
            }
            
            .bottleneck-header {
                display: flex;
                align-items: center;
                gap: 12px;
                margin-bottom: 12px;
            }
            
            .severity-badge {
                margin-left: auto;
                padding: 4px 12px;
                border-radius: 20px;
                font-size: 0.8em;
                font-weight: 600;
            }
            
            .severity-badge.severe {
                background: var(--danger);
                color: white;
            }
            
            .bottleneck-stats {
                margin-bottom: 12px;
                line-height: 1.6;
            }
            
            .bottleneck-suggestion {
                background: var(--bg2);
                border-radius: 6px;
                padding: 12px;
                border-left: 4px solid var(--success);
            }
            
            .relationship-visualization {
                background: var(--bg2);
                border-radius: 8px;
                padding: 20px;
            }
            
            .graph-container {
                text-align: center;
                margin-bottom: 20px;
            }
            
            .graph-controls {
                display: flex;
                justify-content: center;
                gap: 8px;
                margin-top: 12px;
            }
            
            .graph-btn {
                padding: 6px 12px;
                background: var(--bg);
                border: 1px solid var(--border);
                border-radius: 6px;
                cursor: pointer;
                transition: all 0.2s ease;
            }
            
            .graph-btn.active {
                background: var(--primary);
                color: white;
                border-color: var(--primary);
            }
            
            .graph-btn:hover {
                background: var(--primary);
                color: white;
            }
            
            .relationship-details {
                background: var(--bg);
                border: 1px solid var(--border);
                border-radius: 8px;
                padding: 16px;
                margin-top: 16px;
            }
            
            .relationship-list {
                display: flex;
                flex-direction: column;
                gap: 12px;
            }
            
            .relationship-item {
                background: var(--bg2);
                border-radius: 6px;
                padding: 12px;
            }
            
            .relationship-pair {
                font-family: 'Monaco', 'Consolas', monospace;
                font-weight: bold;
                margin-bottom: 4px;
            }
            
            .relationship-strength {
                font-size: 0.9em;
                color: var(--primary);
                font-weight: 600;
            }
            
            .relationship-type {
                font-size: 0.8em;
                color: var(--text2);
            }
            
            @media (max-width: 768px) {
                .memory-pattern-grid {
                    grid-template-columns: 1fr;
                }
                
                .analysis-summary {
                    grid-template-columns: repeat(2, 1fr);
                }
                
                .cross-process-tabs {
                    flex-wrap: wrap;
                }
            }
            
            
            .advanced-patterns-section {
                margin-bottom: 30px;
            }
            
            .pattern-grid {
                display: grid;
                grid-template-columns: 1fr;
                gap: 20px;
                margin-top: 16px;
            }
            
            .pattern-card {
                background: var(--bg);
                border: 2px solid transparent;
                border-radius: 12px;
                padding: 20px;
                transition: all 0.3s ease;
            }
            
            .pattern-card.critical {
                border-color: var(--danger);
                background: rgba(239, 68, 68, 0.03);
            }
            
            .pattern-card.warning {
                border-color: var(--warning);
                background: rgba(245, 158, 11, 0.03);
            }
            
            .pattern-card.info {
                border-color: var(--primary);
                background: rgba(59, 130, 246, 0.03);
            }
            
            .pattern-header {
                display: flex;
                align-items: center;
                gap: 12px;
                margin-bottom: 16px;
                font-size: 1.1em;
                font-weight: 600;
            }
            
            .pattern-severity {
                margin-left: auto;
                padding: 4px 12px;
                border-radius: 20px;
                font-size: 0.8em;
                font-weight: 600;
            }
            
            .pattern-severity.high {
                background: var(--danger);
                color: white;
            }
            
            .pattern-severity.medium {
                background: var(--warning);
                color: white;
            }
            
            .pattern-severity.low {
                background: var(--primary);
                color: white;
            }
            
            .pattern-description {
                margin-bottom: 16px;
                font-size: 0.95em;
                line-height: 1.5;
            }
            
            .visual-evidence {
                background: var(--bg2);
                border-radius: 8px;
                padding: 16px;
                margin: 16px 0;
            }
            
            .evidence-item {
                margin-bottom: 16px;
            }
            
            .evidence-item:last-child {
                margin-bottom: 0;
            }
            
            .evidence-label {
                display: block;
                font-weight: 600;
                margin-bottom: 8px;
                font-size: 0.9em;
                color: var(--text2);
            }
            
            .trend-annotation {
                font-size: 0.8em;
                color: var(--danger);
                margin-top: 4px;
                font-weight: 500;
            }
            
            .related-variables {
                display: flex;
                flex-wrap: wrap;
                gap: 8px;
            }
            
            .variable-chip {
                background: var(--primary);
                color: white;
                padding: 4px 8px;
                border-radius: 12px;
                font-size: 0.8em;
                font-family: 'Monaco', 'Consolas', monospace;
            }
            
            .variable-chip.contention {
                background: var(--warning);
            }
            
            .more-indicator {
                background: var(--text2);
                color: white;
                padding: 4px 8px;
                border-radius: 12px;
                font-size: 0.8em;
                font-style: italic;
            }
            
            .pattern-impact {
                background: rgba(var(--danger-rgb, 239, 68, 68), 0.1);
                border-left: 4px solid var(--danger);
                padding: 12px;
                border-radius: 6px;
                margin: 16px 0;
                font-size: 0.9em;
            }
            
            .pattern-solution {
                background: rgba(var(--success-rgb, 16, 185, 129), 0.1);
                border-left: 4px solid var(--success);
                padding: 12px;
                border-radius: 6px;
                margin-top: 16px;
                font-size: 0.9em;
            }
            
            .pattern-solution .quick-fix-btn {
                margin-top: 8px;
                margin-left: 8px;
            }
            
            /* Mini chart styles */
            .mini-chart-container {
                position: relative;
                display: inline-block;
            }
            
            .chart-overlay {
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                color: var(--danger);
                font-weight: bold;
                font-size: 0.8em;
                pointer-events: none;
            }
        `;
        document.head.appendChild(insightStyles);
    </script>
</body>
</html>